{"version":3,"sources":["../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/%40apollo/server/src/plugin/schemaIsSubgraph.ts","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/%40apollo/server/src/plugin/inlineTrace/index.ts"],"sourcesContent":["import {\n  type GraphQLSchema,\n  isObjectType,\n  isScalarType,\n  isNonNullType,\n} from 'graphql';\n\n// Returns true if it appears that the schema was appears to be of a subgraph\n// (eg, returned from @apollo/subgraph's buildSubgraphSchema). This strategy\n// avoids depending explicitly on @apollo/subgraph or relying on something that\n// might not survive transformations like monkey-patching a boolean field onto\n// the schema.\n//\n// This is used for two things:\n// 1) Determining whether traces should be added to responses if requested with\n//    an HTTP header. If you want to include these traces even for non-subgraphs\n//    (when requested via header, eg for Apollo Explorer's trace view) you can\n//    use ApolloServerPluginInlineTrace explicitly; if you want to never include\n//    these traces even for subgraphs you can use\n//    ApolloServerPluginInlineTraceDisabled.\n// 2) Determining whether schema-reporting should be allowed; subgraphs cannot\n//    report schemas, and we accordingly throw if it's attempted.\nexport function schemaIsSubgraph(schema: GraphQLSchema): boolean {\n  const serviceType = schema.getType('_Service');\n  if (!isObjectType(serviceType)) {\n    return false;\n  }\n  const sdlField = serviceType.getFields().sdl;\n  if (!sdlField) {\n    return false;\n  }\n\n  let sdlFieldType = sdlField.type;\n  if (isNonNullType(sdlFieldType)) {\n    sdlFieldType = sdlFieldType.ofType;\n  }\n  if (!isScalarType(sdlFieldType)) {\n    return false;\n  }\n  return sdlFieldType.name == 'String';\n}\n","import { Trace } from '@apollo/usage-reporting-protobuf';\nimport { TraceTreeBuilder } from '../traceTreeBuilder.js';\nimport type { SendErrorsOptions } from '../usageReporting/index.js';\nimport { internalPlugin } from '../../internalPlugin.js';\nimport { schemaIsSubgraph } from '../schemaIsSubgraph.js';\nimport type { ApolloServerPlugin } from '../../externalTypes/index.js';\n\nexport interface ApolloServerPluginInlineTraceOptions {\n  /**\n   * By default, if a trace contains errors, the errors are included in the\n   * trace with the message `<masked>`. The errors are associated with specific\n   * paths in the operation, but do not include the original error message or\n   * any extensions such as the error `code`, as those details may contain your\n   * users' private data. The extension `maskedBy:\n   * 'ApolloServerPluginInlineTrace'` is added.\n   *\n   * If you'd like details about the error included in traces, set this option.\n   * This option can take several forms:\n   *\n   * - { masked: true }: mask error messages and omit extensions (DEFAULT)\n   * - { unmodified: true }: include all error messages and extensions\n   * - { transform: ... }: a custom function for transforming errors. This\n   *   function receives a `GraphQLError` and may return a `GraphQLError`\n   *   (either a new error, or its potentially-modified argument) or `null`.\n   *   This error is used in the trace; if `null`, the error is not included in\n   *   traces or error statistics.\n   */\n  includeErrors?: SendErrorsOptions;\n  /**\n   * This option is for internal use by `@apollo/server` only.\n   *\n   * By default we want to enable this plugin for subgraph schemas only, but we\n   * need to come up with our list of plugins before we have necessarily loaded\n   * the schema. So (unless the user installs this plugin or\n   * ApolloServerPluginInlineTraceDisabled themselves), `@apollo/server` always\n   * installs this plugin and uses this option to make sure traces are only\n   * included if the schema appears to be a subgraph.\n   */\n  __onlyIfSchemaIsSubgraph?: boolean;\n}\n\n// This ftv1 plugin produces a base64'd Trace protobuf containing only the\n// durationNs, startTime, endTime, and root fields.  This output is placed\n// on the `extensions`.`ftv1` property of the response.  The Apollo Gateway\n// utilizes this data to construct the full trace and submit it to Apollo's\n// usage reporting ingress.\nexport function ApolloServerPluginInlineTrace(\n  options: ApolloServerPluginInlineTraceOptions = Object.create(null),\n): ApolloServerPlugin {\n  let enabled: boolean | null = options.__onlyIfSchemaIsSubgraph ? null : true;\n  return internalPlugin({\n    __internal_plugin_id__: 'InlineTrace',\n    __is_disabled_plugin__: false,\n    async serverWillStart({ schema, logger }) {\n      // Handle the case that the plugin was implicitly installed. We only want it\n      // to actually be active if the schema appears to be federated. If you don't\n      // like the log line, just install `ApolloServerPluginInlineTrace()` in\n      // `plugins` yourself.\n      if (enabled === null) {\n        enabled = schemaIsSubgraph(schema);\n        if (enabled) {\n          logger.info(\n            'Enabling inline tracing for this subgraph. To disable, use ' +\n              'ApolloServerPluginInlineTraceDisabled.',\n          );\n        }\n      }\n    },\n    async requestDidStart({ request: { http }, metrics }) {\n      if (!enabled) {\n        return;\n      }\n\n      const treeBuilder = new TraceTreeBuilder({\n        maskedBy: 'ApolloServerPluginInlineTrace',\n        sendErrors: options.includeErrors,\n      });\n\n      // XXX Provide a mechanism to customize this logic.\n      if (http?.headers.get('apollo-federation-include-trace') !== 'ftv1') {\n        return;\n      }\n\n      // If some other (user-written?) plugin already decided that we are not\n      // capturing traces, then we should not capture traces.\n      if (metrics.captureTraces === false) {\n        return;\n      }\n\n      // Note that this will override any `fieldLevelInstrumentation` parameter\n      // to the usage reporting plugin for requests with the\n      // `apollo-federation-include-trace` header set.\n      metrics.captureTraces = true;\n\n      treeBuilder.startTiming();\n\n      return {\n        async executionDidStart() {\n          return {\n            willResolveField({ info }) {\n              return treeBuilder.willResolveField(info);\n            },\n          };\n        },\n\n        async didEncounterErrors({ errors }) {\n          treeBuilder.didEncounterErrors(errors);\n        },\n\n        async willSendResponse({ response }) {\n          // We record the end time at the latest possible time: right before serializing the trace.\n          // If we wait any longer, the time we record won't actually be sent anywhere!\n          treeBuilder.stopTiming();\n\n          // For now, we don't support inline traces on incremental delivery\n          // responses. (We could perhaps place the trace on the final chunk, or\n          // even deliver it bit by bit. For now, since Gateway does not support\n          // incremental delivery and Router does not pass through defers to\n          // subgraphs, this doesn't affect the \"federated tracing\" use case,\n          // though it does affect the ability to look at inline traces in other\n          // tools like Explorer.\n          if (response.body.kind === 'incremental') {\n            return;\n          }\n\n          // If we're in a gateway, include the query plan (and subgraph traces)\n          // in the inline trace. This is designed more for manually querying\n          // your graph while running locally to see what the query planner is\n          // doing rather than for running in production.\n          if (metrics.queryPlanTrace) {\n            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n          }\n\n          const encodedUint8Array = Trace.encode(treeBuilder.trace).finish();\n          const encodedBuffer = Buffer.from(\n            encodedUint8Array,\n            encodedUint8Array.byteOffset,\n            encodedUint8Array.byteLength,\n          );\n\n          const extensions =\n            response.body.singleResult.extensions ||\n            (response.body.singleResult.extensions = Object.create(null));\n\n          // This should only happen if another plugin is using the same name-\n          // space within the `extensions` object and got to it before us.\n          if (typeof extensions.ftv1 !== 'undefined') {\n            throw new Error('The `ftv1` extension was already present.');\n          }\n\n          extensions.ftv1 = encodedBuffer.toString('base64');\n        },\n      };\n    },\n  });\n}\n"],"names":[],"mappings":"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"}