{"version":3,"sources":["../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/%40apollo/server/src/plugin/usageReporting/durationHistogram.ts","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/%40apollo/server/src/plugin/usageReporting/stats.ts","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/%40apollo/server/src/plugin/usageReporting/traceDetails.ts","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/%40apollo/server/src/plugin/usageReporting/plugin.ts","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/%40apollo/server/src/plugin/usageReporting/iterateOverTrace.ts","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/%40apollo/server/src/plugin/usageReporting/defaultSendOperationsAsTrace.ts","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/%40apollo/server/src/plugin/usageReporting/operationDerivedDataCache.ts","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/%40apollo/server/src/plugin/usageReporting/index.ts"],"sourcesContent":["export interface DurationHistogramOptions {\n  initSize?: number;\n  buckets?: number[];\n}\nexport class DurationHistogram {\n  // Note that it's legal for the values in \"buckets\" to be non-integers; they\n  // will be floored by toArray (which is called by the protobuf encoder).\n  // (We take advantage of this for field latencies specifically, because\n  // the ability to return a non-1 weight from fieldLevelInstrumentation\n  // means we want to build up our histograms as floating-point rather than\n  // rounding after every operation.)\n  private readonly buckets: number[];\n  static readonly BUCKET_COUNT = 384;\n  static readonly EXPONENT_LOG = Math.log(1.1);\n\n  toArray(): number[] {\n    let bufferedZeroes = 0;\n    const outputArray: number[] = [];\n\n    for (const value of this.buckets) {\n      if (value === 0) {\n        bufferedZeroes++;\n      } else {\n        if (bufferedZeroes === 1) {\n          outputArray.push(0);\n        } else if (bufferedZeroes !== 0) {\n          outputArray.push(-bufferedZeroes);\n        }\n        outputArray.push(Math.floor(value));\n        bufferedZeroes = 0;\n      }\n    }\n    return outputArray;\n  }\n\n  static durationToBucket(durationNs: number): number {\n    const log = Math.log(durationNs / 1000.0);\n    const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);\n\n    // Compare <= 0 to catch -0 and -infinity\n    return unboundedBucket <= 0 || Number.isNaN(unboundedBucket)\n      ? 0\n      : unboundedBucket >= DurationHistogram.BUCKET_COUNT\n        ? DurationHistogram.BUCKET_COUNT - 1\n        : unboundedBucket;\n  }\n\n  incrementDuration(durationNs: number, value = 1): DurationHistogram {\n    this.incrementBucket(DurationHistogram.durationToBucket(durationNs), value);\n    return this;\n  }\n\n  incrementBucket(bucket: number, value = 1) {\n    if (bucket >= DurationHistogram.BUCKET_COUNT) {\n      // Since we don't have fixed size arrays I'd rather throw the error manually\n      throw Error('Bucket is out of bounds of the buckets array');\n    }\n\n    // Extend the array if we haven't gotten it long enough to handle the new bucket\n    if (bucket >= this.buckets.length) {\n      const oldLength = this.buckets.length;\n      this.buckets.length = bucket + 1;\n      this.buckets.fill(0, oldLength);\n    }\n\n    this.buckets[bucket] += value;\n  }\n\n  combine(otherHistogram: DurationHistogram) {\n    for (let i = 0; i < otherHistogram.buckets.length; i++) {\n      this.incrementBucket(i, otherHistogram.buckets[i]);\n    }\n  }\n\n  constructor(options?: DurationHistogramOptions) {\n    const initSize = options?.initSize || 74;\n    const buckets = options?.buckets;\n\n    const arrayInitSize = Math.max(buckets?.length || 0, initSize);\n\n    this.buckets = Array<number>(arrayInitSize).fill(0);\n\n    if (buckets) {\n      buckets.forEach((val, index) => (this.buckets[index] = val));\n    }\n  }\n}\n","import type { NonFtv1ErrorPath } from '@apollo/server-gateway-interface';\nimport {\n  type google,\n  type IContextualizedStats,\n  type IFieldStat,\n  type IPathErrorStats,\n  type IQueryLatencyStats,\n  type IReport,\n  type IStatsContext,\n  type ITracesAndStats,\n  type ITypeStat,\n  type ReportHeader,\n  Trace,\n} from '@apollo/usage-reporting-protobuf';\nimport type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';\nimport { DurationHistogram } from './durationHistogram.js';\nimport { iterateOverTrace, type ResponseNamePath } from './iterateOverTrace.js';\n\n// protobuf.js exports both a class and an interface (starting with I) for each\n// message type. The class is what it produces when it decodes the message; the\n// interface is what is accepted as input. We build up our messages using custom\n// types implementing the interfaces, so that we can take advantage of the\n// js_use_toArray option we added to our protobuf.js fork which allows us to use\n// classes like DurationHistogram to generate repeated fields. We end up\n// re-creating most of the report structure as custom classes (starting with\n// \"Our\"). TypeScript validates that we've properly listed all of the message\n// fields with the appropriate types (we use `Required` to ensure we implement\n// all message fields). Using our own classes has other advantages, like being\n// able to specify that nested messages are instances of the same class rather\n// than the interface type and thus that they have non-null fields (because the\n// interface type allows all fields to be optional, even though the protobuf\n// format doesn't differentiate between missing and falsey).\n\nexport class SizeEstimator {\n  bytes = 0;\n}\nexport class OurReport implements Required<IReport> {\n  // Apollo Server includes each operation either as aggregated stats or as a\n  // trace, but not both. Other reporting agents such as Apollo Router include\n  // all operations in stats (even those that are sent as traces), and they set\n  // this flag to true.\n  tracesPreAggregated = false;\n\n  constructor(readonly header: ReportHeader) {}\n  readonly tracesPerQuery: Record<string, OurTracesAndStats> =\n    Object.create(null);\n  endTime: google.protobuf.ITimestamp | null = null;\n  operationCount = 0;\n  // A rough estimate of the number of bytes currently in the report. We start\n  // at zero and don't count `header` and `endTime`, which have the same size\n  // for every report. This really is a rough estimate, so we don't stress too\n  // much about counting bytes for the tags and string/message lengths, etc:\n  // we mostly just count the lengths of strings plus some estimates for the\n  // messages with a bunch of numbers in them.\n  //\n  // We store this in a class so we can pass it down as a reference to other\n  // methods which increment it.\n  readonly sizeEstimator = new SizeEstimator();\n\n  ensureCountsAreIntegers() {\n    for (const tracesAndStats of Object.values(this.tracesPerQuery)) {\n      tracesAndStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace({\n    statsReportKey,\n    trace,\n    asTrace,\n    referencedFieldsByType,\n    // The max size a trace can be before it is sent as stats. Note that the\n    // Apollo reporting ingress server will never store any traces over 10mb\n    // anyway. They will still be converted to stats as we would do here.\n    maxTraceBytes = 10 * 1024 * 1024,\n    nonFtv1ErrorPaths,\n  }: {\n    statsReportKey: string;\n    trace: Trace;\n    asTrace: boolean;\n    referencedFieldsByType: ReferencedFieldsByType;\n    maxTraceBytes?: number;\n    nonFtv1ErrorPaths: NonFtv1ErrorPath[];\n  }) {\n    const tracesAndStats = this.getTracesAndStats({\n      statsReportKey,\n      referencedFieldsByType,\n    });\n    if (asTrace) {\n      const encodedTrace = Trace.encode(trace).finish();\n\n      if (!isNaN(maxTraceBytes) && encodedTrace.length > maxTraceBytes) {\n        tracesAndStats.statsWithContext.addTrace(\n          trace,\n          this.sizeEstimator,\n          nonFtv1ErrorPaths,\n        );\n      } else {\n        tracesAndStats.trace.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    } else {\n      tracesAndStats.statsWithContext.addTrace(\n        trace,\n        this.sizeEstimator,\n        nonFtv1ErrorPaths,\n      );\n    }\n  }\n\n  private getTracesAndStats({\n    statsReportKey,\n    referencedFieldsByType,\n  }: {\n    statsReportKey: string;\n    referencedFieldsByType: ReferencedFieldsByType;\n  }) {\n    const existing = this.tracesPerQuery[statsReportKey];\n    if (existing) {\n      return existing;\n    }\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n\n    // Update the size estimator for the referenced field structure.\n    for (const [typeName, referencedFieldsForType] of Object.entries(\n      referencedFieldsByType,\n    )) {\n      // Two bytes each for the map entry and for the ReferencedFieldsForType,\n      // and for the isInterface bool if it's set.\n      this.sizeEstimator.bytes += 2 + 2;\n      if (referencedFieldsForType.isInterface) {\n        this.sizeEstimator.bytes += 2;\n      }\n      this.sizeEstimator.bytes += estimatedBytesForString(typeName);\n      for (const fieldName of referencedFieldsForType.fieldNames) {\n        this.sizeEstimator.bytes += estimatedBytesForString(fieldName);\n      }\n    }\n\n    // Include the referenced fields map in the report. (In an ideal world we\n    // could have a slightly more sophisticated protocol and ingestion pipeline\n    // that allowed us to only have to send this data once for each\n    // schema/operation pair.)\n    return (this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(\n      referencedFieldsByType,\n    ));\n  }\n}\n\nclass OurTracesAndStats implements Required<ITracesAndStats> {\n  constructor(readonly referencedFieldsByType: ReferencedFieldsByType) {}\n  readonly trace: Uint8Array[] = [];\n  readonly statsWithContext = new StatsByContext();\n  readonly internalTracesContributingToStats: Uint8Array[] = [];\n\n  ensureCountsAreIntegers() {\n    this.statsWithContext.ensureCountsAreIntegers();\n  }\n}\n\nclass StatsByContext {\n  readonly map: { [k: string]: OurContextualizedStats } = Object.create(null);\n\n  /**\n   * This function is used by the protobuf generator to convert this map into\n   * an array of contextualized stats to serialize\n   */\n  toArray(): IContextualizedStats[] {\n    return Object.values(this.map);\n  }\n\n  ensureCountsAreIntegers() {\n    for (const contextualizedStats of Object.values(this.map)) {\n      contextualizedStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n    nonFtv1ErrorPaths: NonFtv1ErrorPath[],\n  ) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(\n      trace,\n      sizeEstimator,\n      nonFtv1ErrorPaths,\n    );\n  }\n\n  private getContextualizedStats(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n  ): OurContextualizedStats {\n    const statsContext: IStatsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion,\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n\n    const existing = this.map[statsContextKey];\n    if (existing) {\n      return existing;\n    }\n    // Adding a ContextualizedStats means adding a StatsContext plus a\n    // QueryLatencyStats. Let's guess about 20 bytes for a QueryLatencyStats;\n    // it'll be more if more features are used (like cache, APQ, etc).\n    sizeEstimator.bytes +=\n      20 +\n      estimatedBytesForString(trace.clientName) +\n      estimatedBytesForString(trace.clientVersion);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n}\n\nexport class OurContextualizedStats implements Required<IContextualizedStats> {\n  queryLatencyStats = new OurQueryLatencyStats();\n  perTypeStat: { [k: string]: OurTypeStat } = Object.create(null);\n\n  constructor(readonly context: IStatsContext) {}\n\n  ensureCountsAreIntegers() {\n    for (const typeStat of Object.values(this.perTypeStat)) {\n      typeStat.ensureCountsAreIntegers();\n    }\n  }\n\n  // Extract statistics from the trace, and increment the estimated report size.\n  // We only add to the estimate when adding whole sub-messages. If it really\n  // mattered, we could do a lot more careful things like incrementing it\n  // whenever a numeric field on queryLatencyStats gets incremented over 0.\n  addTrace(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n    nonFtv1ErrorPaths: NonFtv1ErrorPath[] = [],\n  ) {\n    const { fieldExecutionWeight } = trace;\n    if (!fieldExecutionWeight) {\n      this.queryLatencyStats.requestsWithoutFieldInstrumentation++;\n    }\n\n    this.queryLatencyStats.requestCount++;\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(\n        trace.durationNs,\n      );\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n\n    // We only provide stats about cache TTLs on cache misses (ie, TTLs directly\n    // calculated by the backend), not for cache hits. This matches the\n    // behavior we've had for a while when converting traces into statistics\n    // in Studio's servers.\n    if (!trace.fullQueryCacheHit && trace.cachePolicy?.maxAgeNs != null) {\n      switch (trace.cachePolicy.scope) {\n        case Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n        case Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n      }\n    }\n\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n\n    let hasError = false;\n\n    const errorPathStats = new Set<OurPathErrorStats>();\n\n    const traceNodeStats = (node: Trace.INode, path: ResponseNamePath) => {\n      // Generate error stats and error path information\n      if (node.error?.length) {\n        hasError = true;\n\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach((subPath) => {\n          currPathErrorStats = currPathErrorStats.getChild(\n            subPath,\n            sizeEstimator,\n          );\n        });\n\n        errorPathStats.add(currPathErrorStats);\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n\n      if (fieldExecutionWeight) {\n        // The actual field name behind the node; originalFieldName is set\n        // if an alias was used, otherwise responseName. (This is falsey for\n        // nodes that are not fields (root, array index, etc).)\n        const fieldName = node.originalFieldName || node.responseName;\n\n        // Protobuf doesn't really differentiate between \"unset\" and \"falsey\" so\n        // we're mostly actually checking that these things are non-empty string /\n        // non-zero numbers. The time fields represent the number of nanoseconds\n        // since the beginning of the entire trace, so let's pretend for the\n        // moment that it's plausible for a node to start or even end exactly when\n        // the trace started (ie, for the time values to be 0). This is unlikely\n        // in practice (everything should take at least 1ns). In practice we only\n        // write `type` and `parentType` on a Node when we write `startTime`, so\n        // the main thing we're looking out for by checking the time values is\n        // whether we somehow failed to write `endTime` at the end of the field;\n        // in this case, the `endTime >= startTime` check won't match.\n        if (\n          node.parentType &&\n          fieldName &&\n          node.type &&\n          node.endTime != null &&\n          node.startTime != null &&\n          node.endTime >= node.startTime\n        ) {\n          const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n\n          const fieldStat = typeStat.getFieldStat(\n            fieldName,\n            node.type,\n            sizeEstimator,\n          );\n\n          fieldStat.errorsCount += node.error?.length ?? 0;\n          fieldStat.observedExecutionCount++;\n          fieldStat.estimatedExecutionCount += fieldExecutionWeight;\n          // Note: this is actually counting the number of resolver calls for this\n          // field that had at least one error, not the number of overall GraphQL\n          // queries that had at least one error for this field. That doesn't seem\n          // to match the name, but it does match the other implementations of this\n          // logic.\n          fieldStat.requestsWithErrorsCount +=\n            (node.error?.length ?? 0) > 0 ? 1 : 0;\n          fieldStat.latencyCount.incrementDuration(\n            node.endTime - node.startTime,\n            // The latency histogram is always \"estimated\"; we don't track\n            // \"observed\" and \"estimated\" separately.\n            fieldExecutionWeight,\n          );\n        }\n      }\n\n      return false;\n    };\n\n    iterateOverTrace(trace, traceNodeStats, true);\n\n    // iterate over nonFtv1ErrorPaths, using some bits from traceNodeStats function\n    for (const { subgraph, path } of nonFtv1ErrorPaths) {\n      hasError = true;\n      if (path) {\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats.getChild(\n          `service:${subgraph}`,\n          sizeEstimator,\n        );\n        path.forEach((subPath) => {\n          if (typeof subPath === 'string') {\n            currPathErrorStats = currPathErrorStats.getChild(\n              subPath,\n              sizeEstimator,\n            );\n          }\n        });\n\n        errorPathStats.add(currPathErrorStats);\n        currPathErrorStats.errorsCount += 1;\n      }\n    }\n\n    for (const errorPath of errorPathStats) {\n      errorPath.requestsWithErrorsCount += 1;\n    }\n\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n\n  getTypeStat(parentType: string, sizeEstimator: SizeEstimator): OurTypeStat {\n    const existing = this.perTypeStat[parentType];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n}\n\nclass OurQueryLatencyStats implements Required<IQueryLatencyStats> {\n  latencyCount: DurationHistogram = new DurationHistogram();\n  requestCount = 0;\n  requestsWithoutFieldInstrumentation = 0;\n  cacheHits = 0;\n  persistedQueryHits = 0;\n  persistedQueryMisses = 0;\n  cacheLatencyCount: DurationHistogram = new DurationHistogram();\n  rootErrorStats: OurPathErrorStats = new OurPathErrorStats();\n  requestsWithErrorsCount = 0;\n  publicCacheTtlCount: DurationHistogram = new DurationHistogram();\n  privateCacheTtlCount: DurationHistogram = new DurationHistogram();\n  registeredOperationCount = 0;\n  forbiddenOperationCount = 0;\n}\n\nclass OurPathErrorStats implements Required<IPathErrorStats> {\n  children: { [k: string]: OurPathErrorStats } = Object.create(null);\n  errorsCount = 0;\n  requestsWithErrorsCount = 0;\n\n  getChild(subPath: string, sizeEstimator: SizeEstimator): OurPathErrorStats {\n    const existing = this.children[subPath];\n    if (existing) {\n      return existing;\n    }\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    // Include a few bytes in the estimate for the numbers etc.\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n}\n\nclass OurTypeStat implements Required<ITypeStat> {\n  perFieldStat: { [k: string]: OurFieldStat } = Object.create(null);\n\n  getFieldStat(\n    fieldName: string,\n    returnType: string,\n    sizeEstimator: SizeEstimator,\n  ): OurFieldStat {\n    const existing = this.perFieldStat[fieldName];\n    if (existing) {\n      return existing;\n    }\n    // Rough estimate of 10 bytes for the numbers in the FieldStat.\n    sizeEstimator.bytes +=\n      estimatedBytesForString(fieldName) +\n      estimatedBytesForString(returnType) +\n      10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n\n  ensureCountsAreIntegers() {\n    for (const fieldStat of Object.values(this.perFieldStat)) {\n      fieldStat.ensureCountsAreIntegers();\n    }\n  }\n}\n\nclass OurFieldStat implements Required<IFieldStat> {\n  errorsCount = 0;\n  observedExecutionCount = 0;\n  // Note that this number isn't necessarily an integer while it is being\n  // aggregated. Before encoding as a protobuf we call ensureCountsAreIntegers\n  // which floors it.\n  estimatedExecutionCount = 0;\n  requestsWithErrorsCount = 0;\n  latencyCount: DurationHistogram = new DurationHistogram();\n\n  constructor(readonly returnType: string) {}\n\n  ensureCountsAreIntegers() {\n    // This is the only one that ever can receive non-integers.\n    this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);\n  }\n}\n\nfunction estimatedBytesForString(s: string) {\n  // 2 is for the tag (field ID + wire type) plus the encoded length. (The\n  // encoded length takes up more than 1 byte for strings that are longer than\n  // 127 bytes, but this is an estimate.)\n  return 2 + Buffer.byteLength(s);\n}\n","import { Trace } from '@apollo/usage-reporting-protobuf';\nimport type { VariableValueOptions } from './options.js';\n\n// Creates trace details from request variables, given a specification for modifying\n// values of private or sensitive variables.\n// The details will include all variable names and their (possibly hidden or modified) values.\n// If sendVariableValues is {all: bool}, {none: bool} or {exceptNames: Array}, the option will act similarly to\n// to the to-be-deprecated options.privateVariables, except that the redacted variable\n// names will still be visible in the UI even if the values are hidden.\n// If sendVariableValues is null or undefined, we default to the {none: true} case.\nexport function makeTraceDetails(\n  variables: Record<string, any>,\n  sendVariableValues?: VariableValueOptions,\n  operationString?: string,\n): Trace.Details {\n  const details = new Trace.Details();\n  const variablesToRecord = (() => {\n    if (sendVariableValues && 'transform' in sendVariableValues) {\n      const originalKeys = Object.keys(variables);\n      try {\n        // Custom function to allow user to specify what variablesJson will look like\n        const modifiedVariables = sendVariableValues.transform({\n          variables: variables,\n          operationString: operationString,\n        });\n        return cleanModifiedVariables(originalKeys, modifiedVariables);\n      } catch (e) {\n        // If the custom function provided by the user throws an exception,\n        // change all the variable values to an appropriate error message.\n        return handleVariableValueTransformError(originalKeys);\n      }\n    } else {\n      return variables;\n    }\n  })();\n\n  // Note: we explicitly do *not* include the details.rawQuery field. The\n  // Studio web app currently does nothing with this other than store it in\n  // the database and offer it up via its GraphQL API, and sending it means\n  // that using calculateSignature to hide sensitive data in the query\n  // string is ineffective.\n  Object.keys(variablesToRecord).forEach((name) => {\n    if (\n      !sendVariableValues ||\n      ('none' in sendVariableValues && sendVariableValues.none) ||\n      ('all' in sendVariableValues && !sendVariableValues.all) ||\n      ('exceptNames' in sendVariableValues &&\n        // We assume that most users will have only a few variables values to hide,\n        // or will just set {none: true}; we can change this\n        // linear-time operation if it causes real performance issues.\n        sendVariableValues.exceptNames.includes(name)) ||\n      ('onlyNames' in sendVariableValues &&\n        !sendVariableValues.onlyNames.includes(name))\n    ) {\n      // Special case for private variables. Note that this is a different\n      // representation from a variable containing the empty string, as that\n      // will be sent as '\"\"'.\n      details.variablesJson![name] = '';\n    } else {\n      try {\n        details.variablesJson![name] =\n          typeof variablesToRecord[name] === 'undefined'\n            ? ''\n            : JSON.stringify(variablesToRecord[name]);\n      } catch (e) {\n        details.variablesJson![name] = JSON.stringify(\n          '[Unable to convert value to JSON]',\n        );\n      }\n    }\n  });\n  return details;\n}\n\nfunction handleVariableValueTransformError(\n  variableNames: string[],\n): Record<string, any> {\n  const modifiedVariables = Object.create(null);\n  variableNames.forEach((name) => {\n    modifiedVariables[name] = '[PREDICATE_FUNCTION_ERROR]';\n  });\n  return modifiedVariables;\n}\n\n// Helper for makeTraceDetails() to enforce that the keys of a modified 'variables'\n// matches that of the original 'variables'\nfunction cleanModifiedVariables(\n  originalKeys: Array<string>,\n  modifiedVariables: Record<string, any>,\n): Record<string, any> {\n  const cleanedVariables: Record<string, any> = Object.create(null);\n  originalKeys.forEach((name) => {\n    cleanedVariables[name] = modifiedVariables[name];\n  });\n  return cleanedVariables;\n}\n","import { Report, ReportHeader, Trace } from '@apollo/usage-reporting-protobuf';\nimport type { Fetcher, FetcherResponse } from '@apollo/utils.fetcher';\nimport {\n  usageReportingSignature,\n  calculateReferencedFieldsByType,\n  type ReferencedFieldsByType,\n} from '@apollo/utils.usagereporting';\nimport retry from 'async-retry';\nimport { type GraphQLSchema, printSchema } from 'graphql';\nimport { type LRUCache } from 'lru-cache';\nimport os from 'os';\nimport { gzip } from 'zlib';\nimport type {\n  ApolloServerPlugin,\n  BaseContext,\n  GraphQLRequestContext,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextWillSendResponse,\n  GraphQLRequestListener,\n  GraphQLServerListener,\n} from '../../externalTypes/index.js';\nimport { internalPlugin } from '../../internalPlugin.js';\nimport { dateToProtoTimestamp, TraceTreeBuilder } from '../traceTreeBuilder.js';\nimport { defaultSendOperationsAsTrace } from './defaultSendOperationsAsTrace.js';\nimport {\n  createOperationDerivedDataCache,\n  type OperationDerivedData,\n  operationDerivedDataCacheKey,\n} from './operationDerivedDataCache.js';\nimport type {\n  ApolloServerPluginUsageReportingOptions,\n  SendValuesBaseOptions,\n} from './options.js';\nimport { OurReport } from './stats.js';\nimport { makeTraceDetails } from './traceDetails.js';\nimport { packageVersion } from '../../generated/packageVersion.js';\nimport { computeCoreSchemaHash } from '../../utils/computeCoreSchemaHash.js';\nimport type { HeaderMap } from '../../utils/HeaderMap.js';\nimport { schemaIsSubgraph } from '../schemaIsSubgraph.js';\n\nconst reportHeaderDefaults = {\n  hostname: os.hostname(),\n  agentVersion: `@apollo/server@${packageVersion}`,\n  runtimeVersion: `node ${process.version}`,\n  // XXX not actually uname, but what node has easily.\n  uname: `${os.platform()}, ${os.type()}, ${os.release()}, ${os.arch()})`,\n};\n\nexport function ApolloServerPluginUsageReporting<TContext extends BaseContext>(\n  options: ApolloServerPluginUsageReportingOptions<TContext> = Object.create(\n    null,\n  ),\n): ApolloServerPlugin<TContext> {\n  const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;\n  const fieldLevelInstrumentation =\n    typeof fieldLevelInstrumentationOption === 'number'\n      ? async () =>\n          Math.random() < fieldLevelInstrumentationOption\n            ? 1 / fieldLevelInstrumentationOption\n            : 0\n      : fieldLevelInstrumentationOption\n        ? fieldLevelInstrumentationOption\n        : async () => true;\n\n  let requestDidStartHandler:\n    | ((\n        requestContext: GraphQLRequestContext<TContext>,\n      ) => GraphQLRequestListener<TContext>)\n    | null = null;\n  return internalPlugin({\n    __internal_plugin_id__: 'UsageReporting',\n    __is_disabled_plugin__: false,\n\n    // We want to be able to access locals from `serverWillStart` in our `requestDidStart`, thus\n    // this little hack. (Perhaps we should also allow GraphQLServerListener to contain\n    // a requestDidStart?)\n    async requestDidStart(requestContext: GraphQLRequestContext<TContext>) {\n      if (requestDidStartHandler) {\n        return requestDidStartHandler(requestContext);\n      }\n      // This happens if usage reporting is disabled (eg because this is a\n      // subgraph).\n      return {};\n    },\n\n    async serverWillStart({\n      logger: serverLogger,\n      apollo,\n      startedInBackground,\n      schema,\n    }): Promise<GraphQLServerListener> {\n      // Use the plugin-specific logger if one is provided; otherwise the general server one.\n      const logger = options.logger ?? serverLogger;\n      const { key, graphRef } = apollo;\n      if (!(key && graphRef)) {\n        throw new Error(\n          \"You've enabled usage reporting via ApolloServerPluginUsageReporting, \" +\n            'but you also need to provide your Apollo API key and graph ref, via ' +\n            'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' +\n            'variables or via `new ApolloServer({apollo: {key, graphRef})`.',\n        );\n      }\n\n      if (schemaIsSubgraph(schema)) {\n        if (options.__onlyIfSchemaIsNotSubgraph) {\n          logger.warn(\n            'You have specified an Apollo API key and graph ref but this server appears ' +\n              'to be a subgraph. Typically usage reports are sent to Apollo by your Router ' +\n              'or Gateway, not directly from your subgraph; usage reporting is disabled. To ' +\n              'enable usage reporting anyway, explicitly install `ApolloServerPluginUsageReporting`. ' +\n              'To disable this warning, install `ApolloServerPluginUsageReportingDisabled`.',\n          );\n          // This early return means we don't start background timers, don't\n          // register serverDidStart, don't assign requestDidStartHandler, etc.\n          return {};\n        } else {\n          // This is just a warning; usage reporting is still enabled. If it\n          // turns out there are lots of people who really need to have this odd\n          // setup and they don't like the warning, we can provide a new option\n          // to disable the warning (or they can filter in their `logger`).\n          logger.warn(\n            'You have installed `ApolloServerPluginUsageReporting` but this server appears to ' +\n              'be a subgraph. Typically usage reports are sent to Apollo by your Router ' +\n              'or Gateway, not directly from your subgraph. If this was unintentional, remove ' +\n              \"`ApolloServerPluginUsageReporting` from your server's `plugins` array.\",\n          );\n        }\n      }\n\n      logger.info(\n        'Apollo usage reporting starting! See your graph at ' +\n          `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`,\n      );\n\n      // If sendReportsImmediately is not specified, we default to true if we're running\n      // with the ApolloServer designed for Lambda or similar. That's because these\n      // environments aren't designed around letting us run a background task to\n      // send reports later or hook into container destruction to flush buffered reports.\n      const sendReportsImmediately =\n        options.sendReportsImmediately ?? startedInBackground;\n\n      // Since calculating the signature and referenced fields for usage\n      // reporting is potentially an expensive operation, we'll cache the data\n      // we generate and re-use them for repeated operations for the same\n      // `queryHash`. However, because referenced fields depend on the current\n      // schema, we want to throw it out entirely any time the schema changes.\n      let operationDerivedDataCache: {\n        forSchema: GraphQLSchema;\n        cache: LRUCache<string, OperationDerivedData>;\n      } | null = null;\n\n      // This map maps from executable schema ID (schema hash, basically) to the\n      // report we'll send about it. That's because when we're using a gateway,\n      // the schema can change over time, but each report needs to be about a\n      // single schema. We avoid having this function be a memory leak by\n      // removing values from it when we're in the process of sending reports.\n      // That means we have to be very careful never to pull a Report out of it\n      // and hang on to it for a while before writing to it, because the report\n      // might have gotten sent and discarded in the meantime. So you should\n      // only access the values of this Map via\n      // getReportWhichMustBeUsedImmediately and getAndDeleteReport, and never\n      // hang on to the value returned by getReportWhichMustBeUsedImmediately.\n      const reportByExecutableSchemaId = new Map<string, OurReport>();\n      const getReportWhichMustBeUsedImmediately = (\n        executableSchemaId: string,\n      ): OurReport => {\n        const existing = reportByExecutableSchemaId.get(executableSchemaId);\n        if (existing) {\n          return existing;\n        }\n        const report = new OurReport(\n          new ReportHeader({\n            ...reportHeaderDefaults,\n            executableSchemaId,\n            graphRef,\n          }),\n        );\n        reportByExecutableSchemaId.set(executableSchemaId, report);\n        return report;\n      };\n      const getAndDeleteReport = (\n        executableSchemaId: string,\n      ): OurReport | null => {\n        const report = reportByExecutableSchemaId.get(executableSchemaId);\n        if (report) {\n          reportByExecutableSchemaId.delete(executableSchemaId);\n          return report;\n        }\n        return null;\n      };\n\n      const overriddenExecutableSchemaId = options.overrideReportedSchema\n        ? computeCoreSchemaHash(options.overrideReportedSchema)\n        : undefined;\n\n      let lastSeenExecutableSchemaToId:\n        | {\n            executableSchema: GraphQLSchema;\n            executableSchemaId: string;\n          }\n        | undefined;\n\n      let reportTimer: NodeJS.Timeout | undefined;\n      if (!sendReportsImmediately) {\n        reportTimer = setInterval(\n          () => sendAllReportsAndReportErrors(),\n          options.reportIntervalMs || 10 * 1000,\n        );\n      }\n\n      // We don't send traces if the user set `sendTraces: false`. We also may\n      // set this to false later if the usage-reporting ingress informs us that\n      // this graph does not support viewing traces.\n      let sendTraces = options.sendTraces ?? true;\n      const sendOperationAsTrace =\n        options.experimental_sendOperationAsTrace ??\n        defaultSendOperationsAsTrace();\n\n      let stopped = false;\n\n      function executableSchemaIdForSchema(schema: GraphQLSchema) {\n        if (lastSeenExecutableSchemaToId?.executableSchema === schema) {\n          return lastSeenExecutableSchemaToId.executableSchemaId;\n        }\n        const id = computeCoreSchemaHash(printSchema(schema));\n\n        // We override this variable every time we get a new schema so we cache\n        // the last seen value. It is a single-entry cache.\n        lastSeenExecutableSchemaToId = {\n          executableSchema: schema,\n          executableSchemaId: id,\n        };\n\n        return id;\n      }\n\n      async function sendAllReportsAndReportErrors(): Promise<void> {\n        await Promise.all(\n          [...reportByExecutableSchemaId.keys()].map((executableSchemaId) =>\n            sendReportAndReportErrors(executableSchemaId),\n          ),\n        );\n      }\n\n      async function sendReportAndReportErrors(\n        executableSchemaId: string,\n      ): Promise<void> {\n        return sendReport(executableSchemaId).catch((err) => {\n          // This catch block is primarily intended to catch network errors from\n          // the retried request itself, which include network errors and non-2xx\n          // HTTP errors.\n          if (options.reportErrorFunction) {\n            options.reportErrorFunction(err);\n          } else {\n            logger.error(err.message);\n          }\n        });\n      }\n\n      // Needs to be an arrow function to be confident that key is defined.\n      const sendReport = async (executableSchemaId: string): Promise<void> => {\n        let report = getAndDeleteReport(executableSchemaId);\n        if (\n          !report ||\n          (Object.keys(report.tracesPerQuery).length === 0 &&\n            report.operationCount === 0)\n        ) {\n          return;\n        }\n\n        // Set the report's overall end time. This is the timestamp that will be\n        // associated with the summarized statistics.\n        report.endTime = dateToProtoTimestamp(new Date());\n\n        report.ensureCountsAreIntegers();\n\n        const protobufError = Report.verify(report);\n        if (protobufError) {\n          throw new Error(`Error verifying report: ${protobufError}`);\n        }\n        let message: Uint8Array | null = Report.encode(report).finish();\n        // Let the original protobuf object be garbage collected (helpful if the\n        // HTTP request hangs).\n        report = null;\n\n        // Potential follow-up: we can compare message.length to\n        // report.sizeEstimator.bytes and use it to \"learn\" if our estimation is\n        // off and adjust it based on what we learn.\n\n        if (options.debugPrintReports) {\n          // We decode the report rather than printing the original `report`\n          // so that it includes all of the pre-encoded traces.\n          const decodedReport = Report.decode(message);\n          logger.info(\n            `Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`,\n          );\n        }\n\n        const compressed = await new Promise<Buffer>((resolve, reject) => {\n          gzip(message!, (error, result) => {\n            error ? reject(error) : resolve(result);\n          });\n        });\n        // Let the uncompressed message be garbage collected (helpful if the\n        // HTTP request is slow).\n        message = null;\n\n        // Wrap fetcher with async-retry for automatic retrying\n        const fetcher: Fetcher = options.fetcher ?? fetch;\n        const response: FetcherResponse = await retry(\n          // Retry on network errors and 5xx HTTP\n          // responses.\n          async () => {\n            const curResponse = await fetcher(\n              (options.endpointUrl ||\n                'https://usage-reporting.api.apollographql.com') +\n                '/api/ingress/traces',\n              {\n                method: 'POST',\n                headers: {\n                  'user-agent': 'ApolloServerPluginUsageReporting',\n                  'x-api-key': key,\n                  'content-encoding': 'gzip',\n                  accept: 'application/json',\n                },\n                body: compressed,\n                signal: AbortSignal.timeout(options.requestTimeoutMs ?? 30_000),\n              },\n            );\n\n            if (curResponse.status >= 500 && curResponse.status < 600) {\n              throw new Error(\n                `HTTP status ${curResponse.status}, ${\n                  (await curResponse.text()) || '(no body)'\n                }`,\n              );\n            } else {\n              return curResponse;\n            }\n          },\n          {\n            retries: (options.maxAttempts || 5) - 1,\n            minTimeout: options.minimumRetryDelayMs || 100,\n            factor: 2,\n          },\n        ).catch((err: Error) => {\n          throw new Error(\n            `Error sending report to Apollo servers: ${err.message}`,\n          );\n        });\n\n        if (response.status < 200 || response.status >= 300) {\n          // Note that we don't expect to see a 3xx here because request follows\n          // redirects.\n          throw new Error(\n            `Error sending report to Apollo servers: HTTP status ${\n              response.status\n            }, ${(await response.text()) || '(no body)'}`,\n          );\n        }\n\n        if (\n          sendTraces &&\n          response.status === 200 &&\n          response.headers\n            .get('content-type')\n            ?.match(/^\\s*application\\/json\\s*(?:;|$)/i)\n        ) {\n          const body = await response.text();\n          let parsedBody;\n          try {\n            parsedBody = JSON.parse(body);\n          } catch (e) {\n            throw new Error(`Error parsing response from Apollo servers: ${e}`);\n          }\n          if (parsedBody.tracesIgnored === true) {\n            logger.debug(\n              \"This graph's organization does not have access to traces; sending all \" +\n                'subsequent operations as stats.',\n            );\n            sendTraces = false;\n          }\n        }\n        if (options.debugPrintReports) {\n          logger.info(`Apollo usage report: status ${response.status}`);\n        }\n      };\n\n      requestDidStartHandler = ({\n        metrics,\n        schema,\n        request: { http, variables },\n      }): GraphQLRequestListener<TContext> => {\n        const treeBuilder: TraceTreeBuilder = new TraceTreeBuilder({\n          maskedBy: 'ApolloServerPluginUsageReporting',\n          sendErrors: options.sendErrors,\n        });\n        treeBuilder.startTiming();\n        metrics.startHrTime = treeBuilder.startHrTime;\n        let graphqlValidationFailure = false;\n        let graphqlUnknownOperationName = false;\n        let includeOperationInUsageReporting: boolean | null = null;\n\n        if (http) {\n          treeBuilder.trace.http = new Trace.HTTP({\n            method:\n              Trace.HTTP.Method[\n                http.method as keyof typeof Trace.HTTP.Method\n              ] || Trace.HTTP.Method.UNKNOWN,\n          });\n\n          if (options.sendHeaders) {\n            makeHTTPRequestHeaders(\n              treeBuilder.trace.http,\n              http.headers,\n              options.sendHeaders,\n            );\n          }\n        }\n\n        // After this function completes, includeOperationInUsageReporting is\n        // defined.\n        async function maybeCallIncludeRequestHook(\n          requestContext:\n            | GraphQLRequestContextDidResolveOperation<TContext>\n            | GraphQLRequestContextWillSendResponse<TContext>,\n        ): Promise<void> {\n          // If this is the second call in `willSendResponse` after\n          // `didResolveOperation`, we're done.\n          if (includeOperationInUsageReporting !== null) return;\n\n          if (typeof options.includeRequest !== 'function') {\n            // Default case we always report\n            includeOperationInUsageReporting = true;\n            return;\n          }\n          includeOperationInUsageReporting =\n            await options.includeRequest(requestContext);\n\n          // Help the user understand they've returned an unexpected value,\n          // which might be a subtle mistake.\n          if (typeof includeOperationInUsageReporting !== 'boolean') {\n            logger.warn(\n              \"The 'includeRequest' async predicate function must return a boolean value.\",\n            );\n            includeOperationInUsageReporting = true;\n          }\n        }\n\n        // Our usage reporting groups everything by operation, so we don't\n        // actually report about any issues that prevent us from getting an\n        // operation string (eg, a missing operation, or APQ problems).\n        // This is effectively bypassing the reporting of:\n        //   - PersistedQueryNotFoundError\n        //   - PersistedQueryNotSupportedError\n        //   - Missing `query` error\n        // We may want to report them some other way later!\n        let didResolveSource = false;\n\n        return {\n          async didResolveSource(requestContext) {\n            didResolveSource = true;\n\n            if (metrics.persistedQueryHit) {\n              treeBuilder.trace.persistedQueryHit = true;\n            }\n            if (metrics.persistedQueryRegister) {\n              treeBuilder.trace.persistedQueryRegister = true;\n            }\n\n            if (variables) {\n              treeBuilder.trace.details = makeTraceDetails(\n                variables,\n                options.sendVariableValues,\n                requestContext.source,\n              );\n            }\n\n            const clientInfo = (\n              options.generateClientInfo || defaultGenerateClientInfo\n            )(requestContext);\n            if (clientInfo) {\n              // While there is a clientAddress protobuf field, the backend\n              // doesn't pay attention to it yet, so we'll ignore it for now.\n              const { clientName, clientVersion } = clientInfo;\n              treeBuilder.trace.clientVersion = clientVersion || '';\n              treeBuilder.trace.clientName = clientName || '';\n            }\n          },\n          async validationDidStart() {\n            return async (validationErrors?: ReadonlyArray<Error>) => {\n              graphqlValidationFailure = validationErrors\n                ? validationErrors.length !== 0\n                : false;\n            };\n          },\n          async didResolveOperation(requestContext) {\n            // If operation is undefined then `getOperationAST` returned null\n            // and an unknown operation was specified.\n            graphqlUnknownOperationName =\n              requestContext.operation === undefined;\n            await maybeCallIncludeRequestHook(requestContext);\n\n            if (\n              includeOperationInUsageReporting &&\n              // No need to capture traces if the operation is going to\n              // immediately fail due to unknown operation name.\n              !graphqlUnknownOperationName\n            ) {\n              if (metrics.captureTraces === undefined) {\n                // We're not completely ignoring the operation. But should we\n                // calculate a detailed trace of every field while we do so (either\n                // directly in this plugin, or in a subgraph by sending the\n                // apollo-federation-include-trace header)? That will allow this\n                // operation to contribute to the \"field executions\" column in the\n                // Studio Fields page, to the timing hints in Explorer and\n                // vscode-graphql, and to the traces visible under Operations. (Note\n                // that `true` here does not imply that this operation will\n                // necessarily be *sent* to the usage-reporting endpoint in the form\n                // of a trace --- it still might be aggregated into stats first. But\n                // capturing a trace will mean we can understand exactly what fields\n                // were executed and what their performance was, at the tradeoff of\n                // some overhead for tracking the trace (and transmitting it between\n                // subgraph and gateway).\n                const rawWeight =\n                  await fieldLevelInstrumentation(requestContext);\n                treeBuilder.trace.fieldExecutionWeight =\n                  typeof rawWeight === 'number' ? rawWeight : rawWeight ? 1 : 0;\n\n                metrics.captureTraces =\n                  !!treeBuilder.trace.fieldExecutionWeight;\n              }\n            }\n          },\n          async executionDidStart() {\n            // If we're not capturing traces, don't return a willResolveField so\n            // that we don't build up a detailed trace inside treeBuilder. (We still\n            // will use treeBuilder as a convenient place to put top-level facts\n            // about the operation which can end up aggregated as stats, and we do\n            // eventually put *errors* onto the trace tree.)\n            if (!metrics.captureTraces) return;\n\n            return {\n              willResolveField({ info }) {\n                return treeBuilder.willResolveField(info);\n                // We could save the error into the trace during the end handler, but\n                // it won't have all the information that graphql-js adds to it later,\n                // like 'locations'.\n              },\n            };\n          },\n\n          async didEncounterSubsequentErrors(_requestContext, errors) {\n            treeBuilder.didEncounterErrors(errors);\n          },\n\n          async willSendSubsequentPayload(requestContext, payload) {\n            if (!payload.hasNext) {\n              await operationFinished(requestContext);\n            }\n          },\n\n          async willSendResponse(requestContext) {\n            // Search above for a comment about \"didResolveSource\" to see which\n            // of the pre-source-resolution errors we are intentionally avoiding.\n            if (!didResolveSource) return;\n            if (requestContext.errors) {\n              treeBuilder.didEncounterErrors(requestContext.errors);\n            }\n\n            // If there isn't any defer/stream coming later, we're done.\n            // Otherwise willSendSubsequentPayload will trigger\n            // operationFinished.\n            if (requestContext.response.body.kind === 'single') {\n              await operationFinished(requestContext);\n            }\n          },\n        };\n\n        async function operationFinished(\n          requestContext: GraphQLRequestContextWillSendResponse<TContext>,\n        ) {\n          const resolvedOperation = !!requestContext.operation;\n\n          // If we got an error before we called didResolveOperation (eg parse or\n          // validation error), check to see if we should include the request.\n          await maybeCallIncludeRequestHook(requestContext);\n\n          treeBuilder.stopTiming();\n          const executableSchemaId =\n            overriddenExecutableSchemaId ?? executableSchemaIdForSchema(schema);\n\n          if (includeOperationInUsageReporting === false) {\n            if (resolvedOperation) {\n              getReportWhichMustBeUsedImmediately(executableSchemaId)\n                .operationCount++;\n            }\n            return;\n          }\n\n          treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;\n          treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;\n          treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;\n\n          const policyIfCacheable =\n            requestContext.overallCachePolicy.policyIfCacheable();\n          if (policyIfCacheable) {\n            treeBuilder.trace.cachePolicy = new Trace.CachePolicy({\n              scope:\n                policyIfCacheable.scope === 'PRIVATE'\n                  ? Trace.CachePolicy.Scope.PRIVATE\n                  : policyIfCacheable.scope === 'PUBLIC'\n                    ? Trace.CachePolicy.Scope.PUBLIC\n                    : Trace.CachePolicy.Scope.UNKNOWN,\n              // Convert from seconds to ns.\n              maxAgeNs: policyIfCacheable.maxAge * 1e9,\n            });\n          }\n\n          // If this was a federated operation and we're the gateway, add the query plan\n          // to the trace.\n          if (metrics.queryPlanTrace) {\n            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n          }\n\n          // Intentionally un-awaited so as not to block the response.  Any\n          // errors will be logged, but will not manifest a user-facing error.\n          // The logger in this case is a request specific logger OR the logger\n          // defined by the plugin if that's unavailable.  The request-specific\n          // logger is preferred since this is very much coupled directly to a\n          // client-triggered action which might be more granularly tagged by\n          // logging implementations.\n          addTrace().catch(logger.error.bind(logger));\n\n          async function addTrace(): Promise<void> {\n            // Ignore traces that come in after stop().\n            if (stopped) {\n              return;\n            }\n\n            // Ensure that the caller of addTrace (which does not await it) is\n            // not blocked. We use setImmediate rather than process.nextTick or\n            // just relying on the Promise microtask queue because setImmediate\n            // comes after IO, which is what we want.\n            await new Promise((res) => setImmediate(res));\n\n            const executableSchemaId =\n              overriddenExecutableSchemaId ??\n              executableSchemaIdForSchema(schema);\n\n            const { trace } = treeBuilder;\n\n            let statsReportKey: string | undefined = undefined;\n            let referencedFieldsByType: ReferencedFieldsByType;\n            if (!requestContext.document) {\n              statsReportKey = `## GraphQLParseFailure\\n`;\n            } else if (graphqlValidationFailure) {\n              statsReportKey = `## GraphQLValidationFailure\\n`;\n            } else if (graphqlUnknownOperationName) {\n              statsReportKey = `## GraphQLUnknownOperationName\\n`;\n            }\n\n            const isExecutable = statsReportKey === undefined;\n\n            if (statsReportKey) {\n              if (options.sendUnexecutableOperationDocuments) {\n                trace.unexecutedOperationBody = requestContext.source;\n                // Get the operation name from the request (which might not\n                // correspond to an actual operation).\n                trace.unexecutedOperationName =\n                  requestContext.request.operationName || '';\n              }\n              referencedFieldsByType = Object.create(null);\n            } else {\n              const operationDerivedData = getOperationDerivedData();\n              statsReportKey = `# ${requestContext.operationName || '-'}\\n${\n                operationDerivedData.signature\n              }`;\n              referencedFieldsByType =\n                operationDerivedData.referencedFieldsByType;\n            }\n\n            const protobufError = Trace.verify(trace);\n            if (protobufError) {\n              throw new Error(`Error encoding trace: ${protobufError}`);\n            }\n\n            if (resolvedOperation) {\n              getReportWhichMustBeUsedImmediately(executableSchemaId)\n                .operationCount++;\n            }\n\n            getReportWhichMustBeUsedImmediately(executableSchemaId).addTrace({\n              statsReportKey,\n              trace,\n              // We include the operation as a trace (rather than aggregated into stats) only if:\n              // * the user didn't set `sendTraces: false` AND\n              // * it's possible that the organization's plan allows for viewing traces AND\n              // * we captured this as a full trace AND\n              // * gateway reported no errors missing ftv1 data AND\n              // * sendOperationAsTrace says so\n              //\n              // (As an edge case, if the reason metrics.captureTraces is\n              // falsey is that this is an unexecutable operation and thus we\n              // never ran the code in didResolveOperation that sets\n              // metrics.captureTrace, we allow it to be sent as a trace. This\n              // means we'll still send some parse and validation failures as\n              // traces, for the sake of the Errors page.)\n              asTrace:\n                sendTraces &&\n                (!isExecutable || !!metrics.captureTraces) &&\n                !metrics.nonFtv1ErrorPaths?.length &&\n                sendOperationAsTrace(trace, statsReportKey),\n              referencedFieldsByType,\n              nonFtv1ErrorPaths: metrics.nonFtv1ErrorPaths ?? [],\n            });\n\n            // If the buffer gets big (according to our estimate), send.\n            if (\n              sendReportsImmediately ||\n              getReportWhichMustBeUsedImmediately(executableSchemaId)\n                .sizeEstimator.bytes >=\n                (options.maxUncompressedReportSize || 4 * 1024 * 1024)\n            ) {\n              await sendReportAndReportErrors(executableSchemaId);\n            }\n          }\n\n          // Calculates signature and referenced fields for the current document.\n          // Only call this when the document properly parses and validates and\n          // the given operation name (if any) is known!\n          function getOperationDerivedData(): OperationDerivedData {\n            if (!requestContext.document) {\n              // This shouldn't happen: no document means parse failure, which\n              // uses its own special statsReportKey.\n              throw new Error('No document?');\n            }\n\n            const cacheKey = operationDerivedDataCacheKey(\n              requestContext.queryHash,\n              requestContext.operationName || '',\n            );\n\n            // Ensure that the cache we have is for the right schema.\n            if (\n              !operationDerivedDataCache ||\n              operationDerivedDataCache.forSchema !== schema\n            ) {\n              operationDerivedDataCache = {\n                forSchema: schema,\n                cache: createOperationDerivedDataCache({ logger }),\n              };\n            }\n\n            // If we didn't have the signature in the cache, we'll resort to\n            // calculating it.\n            const cachedOperationDerivedData =\n              operationDerivedDataCache.cache.get(cacheKey);\n            if (cachedOperationDerivedData) {\n              return cachedOperationDerivedData;\n            }\n\n            const generatedSignature = (\n              options.calculateSignature || usageReportingSignature\n            )(requestContext.document, requestContext.operationName || '');\n\n            const generatedOperationDerivedData: OperationDerivedData = {\n              signature: generatedSignature,\n              referencedFieldsByType: calculateReferencedFieldsByType({\n                document: requestContext.document,\n                schema,\n                resolvedOperationName: requestContext.operationName ?? null,\n              }),\n            };\n\n            // Note that this cache is always an in-memory cache.\n            // If we replace it with a more generic async cache, we should\n            // not await the write operation.\n            operationDerivedDataCache.cache.set(\n              cacheKey,\n              generatedOperationDerivedData,\n            );\n            return generatedOperationDerivedData;\n          }\n        }\n      };\n\n      return {\n        async serverWillStop() {\n          if (reportTimer) {\n            clearInterval(reportTimer);\n            reportTimer = undefined;\n          }\n\n          stopped = true;\n          await sendAllReportsAndReportErrors();\n        },\n      };\n    },\n  });\n}\n\nexport function makeHTTPRequestHeaders(\n  http: Trace.IHTTP,\n  headers: HeaderMap,\n  sendHeaders?: SendValuesBaseOptions,\n): void {\n  if (\n    !sendHeaders ||\n    ('none' in sendHeaders && sendHeaders.none) ||\n    ('all' in sendHeaders && !sendHeaders.all)\n  ) {\n    return;\n  }\n  for (const [key, value] of headers) {\n    // Note that HeaderMap keys are already lower-case.\n    if (\n      ('exceptNames' in sendHeaders &&\n        // We assume that most users only have a few headers to hide, or will\n        // just set {none: true} ; we can change this linear-time\n        // operation if it causes real performance issues.\n        sendHeaders.exceptNames.some((exceptHeader) => {\n          // Headers are case-insensitive, and should be compared as such.\n          return exceptHeader.toLowerCase() === key;\n        })) ||\n      ('onlyNames' in sendHeaders &&\n        !sendHeaders.onlyNames.some((header) => {\n          return header.toLowerCase() === key;\n        }))\n    ) {\n      continue;\n    }\n\n    switch (key) {\n      case 'authorization':\n      case 'cookie':\n      case 'set-cookie':\n        break;\n      default:\n        http!.requestHeaders![key] = new Trace.HTTP.Values({\n          value: [value],\n        });\n    }\n  }\n}\n\nfunction defaultGenerateClientInfo<TContext extends BaseContext>({\n  request,\n}: GraphQLRequestContext<TContext>) {\n  const clientNameHeaderKey = 'apollographql-client-name';\n  const clientVersionHeaderKey = 'apollographql-client-version';\n\n  // Default to using the `apollo-client-x` header fields if present.\n  // If none are present, fallback on the `clientInfo` query extension\n  // for backwards compatibility.\n  // The default value if neither header values nor query extension is\n  // set is the empty String for all fields (as per protobuf defaults)\n  if (\n    request.http?.headers?.get(clientNameHeaderKey) ||\n    request.http?.headers?.get(clientVersionHeaderKey)\n  ) {\n    return {\n      clientName: request.http?.headers?.get(clientNameHeaderKey),\n      clientVersion: request.http?.headers?.get(clientVersionHeaderKey),\n    };\n  } else if (request.extensions?.clientInfo) {\n    return request.extensions.clientInfo;\n  } else {\n    return {};\n  }\n}\n","import type { Trace } from '@apollo/usage-reporting-protobuf';\n\n/**\n * Iterates over the entire trace, calling `f` on each Trace.Node found. It\n * looks under the \"root\" node as well as any inside the query plan. If any `f`\n * returns true, it stops walking the tree.\n *\n * Each call to `f` will receive an object that implements ResponseNamePath. If\n * `includePath` is true, `f` can call `toArray()` on it to convert the\n * linked-list representation to an array of the response name (field name)\n * nodes that you navigate to get to the node (including a \"service:subgraph\"\n * top-level node if this is a federated trace). Note that we don't add anything\n * to the path for index (list element) nodes. This is because the only use case\n * we have (error path statistics) does not care about list indexes (it's not\n * that interesting to know that sometimes an error was at foo.3.bar and\n * sometimes foo.5.bar, vs just generally foo.bar).\n *\n * If `includePath` is false, we don't bother to build up the linked lists, and\n * calling `toArray()` will throw.\n */\nexport function iterateOverTrace(\n  trace: Trace,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n  includePath: boolean,\n) {\n  const rootPath = includePath\n    ? new RootCollectingPathsResponseNamePath()\n    : notCollectingPathsResponseNamePath;\n  if (trace.root) {\n    if (iterateOverTraceNode(trace.root, rootPath, f)) return;\n  }\n\n  if (trace.queryPlan) {\n    if (iterateOverQueryPlan(trace.queryPlan, rootPath, f)) return;\n  }\n}\n\n// Helper for iterateOverTrace; returns true to stop the overall walk.\nfunction iterateOverQueryPlan(\n  node: Trace.IQueryPlanNode,\n  rootPath: ResponseNamePath,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n): boolean {\n  if (!node) return false;\n\n  if (node.fetch?.trace?.root && node.fetch.serviceName) {\n    return iterateOverTraceNode(\n      node.fetch.trace.root,\n      rootPath.child(`service:${node.fetch.serviceName}`),\n      f,\n    );\n  }\n  if (node.flatten?.node) {\n    return iterateOverQueryPlan(node.flatten.node, rootPath, f);\n  }\n  if (node.parallel?.nodes) {\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    return node.parallel.nodes.some((node) =>\n      iterateOverQueryPlan(node, rootPath, f),\n    );\n  }\n  if (node.sequence?.nodes) {\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    return node.sequence.nodes.some((node) =>\n      iterateOverQueryPlan(node, rootPath, f),\n    );\n  }\n\n  return false;\n}\n\n// Helper for iterateOverTrace; returns true to stop the overall walk.\nfunction iterateOverTraceNode(\n  node: Trace.INode,\n  path: ResponseNamePath,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n): boolean {\n  // Invoke the function; if it returns true, don't descend and tell callers to\n  // stop walking.\n  if (f(node, path)) {\n    return true;\n  }\n\n  return (\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    node.child?.some((child) => {\n      const childPath = child.responseName\n        ? path.child(child.responseName)\n        : path;\n      return iterateOverTraceNode(child, childPath, f);\n    }) ?? false\n  );\n}\n\nexport interface ResponseNamePath {\n  toArray(): string[];\n  child(responseName: string): ResponseNamePath;\n}\n\nconst notCollectingPathsResponseNamePath: ResponseNamePath = {\n  toArray() {\n    throw Error('not collecting paths!');\n  },\n  child() {\n    return this;\n  },\n};\n\ntype CollectingPathsResponseNamePath =\n  | RootCollectingPathsResponseNamePath\n  | ChildCollectingPathsResponseNamePath;\nclass RootCollectingPathsResponseNamePath implements ResponseNamePath {\n  toArray() {\n    return [];\n  }\n  child(responseName: string) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\nclass ChildCollectingPathsResponseNamePath implements ResponseNamePath {\n  constructor(\n    readonly responseName: string,\n    readonly prev: CollectingPathsResponseNamePath,\n  ) {}\n  toArray() {\n    const out = [];\n    let curr: CollectingPathsResponseNamePath = this;\n    while (curr instanceof ChildCollectingPathsResponseNamePath) {\n      out.push(curr.responseName);\n      curr = curr.prev;\n    }\n    return out.reverse();\n  }\n  child(responseName: string) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\n","import { LRUCache } from 'lru-cache';\nimport type { Trace } from '@apollo/usage-reporting-protobuf';\nimport { iterateOverTrace } from './iterateOverTrace.js';\nimport { DurationHistogram } from './durationHistogram.js';\n\nexport function defaultSendOperationsAsTrace() {\n  // We keep an LRU cache mapping from a trace key (which consists of the\n  // operation as defined by statsReportKey, the rough duration of the\n  // operation, what minute the operation ended at, etc) to `true` if we've seen\n  // it recently. We actually split this into one cache per minute so we can\n  // throw away a full minute's worth of cache at once; we keep only the last\n  // three minutes.\n  // Note that if a trace is over a certain size, we will always send it as\n  // stats. We check this within the addTrace function of the OurReport class so\n  // that we don't have to encode these large traces twice.\n  const cache = new LRUCache<string, true>({\n    // 3MiB limit, very much approximately since we can't be sure how V8 might\n    // be storing these strings internally. Though this should be enough to\n    // store a fair amount of trace keys.\n\n    // A future version of this might expose some\n    // configuration option to grow the cache, but ideally, we could do that\n    // dynamically based on the resources available to the server, and not add\n    // more configuration surface area. Hopefully the warning message will allow\n    // us to evaluate the need with more validated input from those that receive\n    // it.\n    maxSize: Math.pow(2, 20),\n    sizeCalculation: (_val, key) => {\n      return (key && Buffer.byteLength(key)) || 0;\n    },\n  });\n\n  return (trace: Trace, statsReportKey: string): boolean => {\n    const endTimeSeconds = trace.endTime?.seconds;\n    if (endTimeSeconds == null) {\n      throw Error('programming error: endTime not set on trace');\n    }\n\n    const hasErrors = traceHasErrors(trace);\n    const cacheKey = JSON.stringify([\n      statsReportKey,\n      DurationHistogram.durationToBucket(trace.durationNs),\n      // What minute it started at\n      Math.floor(endTimeSeconds / 60),\n      // If the trace has an error, send one errored trace per 5 second interval\n      // instead of the normal minutely bucket a non-errored trace takes.\n      hasErrors ? Math.floor(endTimeSeconds / 5) : '',\n    ]);\n\n    // If we've already seen something roughly like this, don't send as a trace.\n    if (cache.get(cacheKey)) {\n      return false;\n    }\n\n    cache.set(cacheKey, true);\n    return true;\n  };\n}\n\n// Returns true if any node on the trace has errors. (If this ends up being a\n// hot spot, we can precalculate it in TraceTreeBuilder.)\nfunction traceHasErrors(trace: Trace): boolean {\n  let hasErrors = false;\n\n  function traceNodeStats(node: Trace.INode): boolean {\n    if ((node.error?.length ?? 0) > 0) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n\n  iterateOverTrace(trace, traceNodeStats, false);\n  return hasErrors;\n}\n","import type { Logger } from '@apollo/utils.logger';\nimport type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';\nimport { LRUCache } from 'lru-cache';\n\nexport interface OperationDerivedData {\n  signature: string;\n  referencedFieldsByType: ReferencedFieldsByType;\n}\n\nexport function createOperationDerivedDataCache({\n  logger,\n}: {\n  logger: Logger;\n}): LRUCache<string, OperationDerivedData> {\n  let lastWarn: Date;\n  let lastDisposals = 0;\n  return new LRUCache<string, OperationDerivedData>({\n    // Calculate the length of cache objects by the JSON.stringify byteLength.\n    sizeCalculation(obj) {\n      return Buffer.byteLength(JSON.stringify(obj), 'utf8');\n    },\n    // 10MiB limit, very much approximately since we can't be sure how V8 might\n    // be storing this data internally. Though this should be enough to store a\n    // fair amount of operation data, depending on their overall complexity. A\n    // future version of this might expose some configuration option to grow the\n    // cache, but ideally, we could do that dynamically based on the resources\n    // available to the server, and not add more configuration surface area.\n    // Hopefully the warning message will allow us to evaluate the need with\n    // more validated input from those that receive it.\n    maxSize: Math.pow(2, 20) * 10,\n    dispose() {\n      // Count the number of disposals between warning messages.\n      lastDisposals++;\n\n      // Only show a message warning about the high turnover every 60 seconds.\n      if (!lastWarn || new Date().getTime() - lastWarn.getTime() > 60000) {\n        // Log the time that we last displayed the message.\n        lastWarn = new Date();\n        logger.warn(\n          [\n            'This server is processing a high number of unique operations.  ',\n            `A total of ${lastDisposals} records have been `,\n            'ejected from the ApolloServerPluginUsageReporting signature cache in the past ',\n            'interval.  If you see this warning frequently, please open an ',\n            'issue on the Apollo Server repository.',\n          ].join(''),\n        );\n\n        // Reset the disposal counter for the next message interval.\n        lastDisposals = 0;\n      }\n    },\n  });\n}\n\nexport function operationDerivedDataCacheKey(\n  queryHash: string,\n  operationName: string,\n) {\n  return `${queryHash}${operationName && ':' + operationName}`;\n}\n","export { ApolloServerPluginUsageReporting } from './plugin.js';\nexport type {\n  ApolloServerPluginUsageReportingOptions,\n  SendValuesBaseOptions,\n  VariableValueOptions,\n  SendErrorsOptions,\n  ClientInfo,\n  GenerateClientInfo,\n} from './options.js';\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7]}