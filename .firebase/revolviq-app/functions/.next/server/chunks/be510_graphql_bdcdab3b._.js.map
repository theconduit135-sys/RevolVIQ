{"version":3,"sources":["../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/version.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/utilities/getOperationAST.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/execution/execute.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/jsutils/isPromise.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/jsutils/memoize3.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/jsutils/promiseForObject.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/jsutils/promiseReduce.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/jsutils/toError.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/error/locatedError.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/graphql.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/execution/subscribe.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/jsutils/isAsyncIterable.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/execution/mapAsyncIterator.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/utilities/getIntrospectionQuery.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/utilities/getOperationRootType.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/utilities/introspectionFromSchema.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/utilities/buildClientSchema.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/utilities/lexicographicSortSchema.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/utilities/concatAST.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/utilities/separateOperations.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/utilities/stripIgnoredCharacters.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/utilities/assertValidName.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/utilities/findBreakingChanges.mjs","../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/graphql/utilities/resolveSchemaCoordinate.mjs"],"sourcesContent":["// Note: This file is autogenerated using \"resources/gen-version.js\" script and\n// automatically updated by \"npm version\" command.\n\n/**\n * A string containing the version of the GraphQL.js library\n */\nexport const version = '16.12.0';\n/**\n * An object containing the components of the GraphQL.js version string\n */\n\nexport const versionInfo = Object.freeze({\n  major: 16,\n  minor: 12,\n  patch: 0,\n  preReleaseTag: null,\n});\n","import { Kind } from '../language/kinds.mjs';\n/**\n * Returns an operation AST given a document AST and optionally an operation\n * name. If a name is not provided, an operation is only returned if only one is\n * provided in the document.\n */\n\nexport function getOperationAST(documentAST, operationName) {\n  let operation = null;\n\n  for (const definition of documentAST.definitions) {\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      var _definition$name;\n\n      if (operationName == null) {\n        // If no operation name was provided, only return an Operation if there\n        // is one defined in the document. Upon encountering the second, return\n        // null.\n        if (operation) {\n          return null;\n        }\n\n        operation = definition;\n      } else if (\n        ((_definition$name = definition.name) === null ||\n        _definition$name === void 0\n          ? void 0\n          : _definition$name.value) === operationName\n      ) {\n        return definition;\n      }\n    }\n  }\n\n  return operation;\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { isPromise } from '../jsutils/isPromise.mjs';\nimport { memoize3 } from '../jsutils/memoize3.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { promiseForObject } from '../jsutils/promiseForObject.mjs';\nimport { promiseReduce } from '../jsutils/promiseReduce.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isAbstractType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../type/definition.mjs';\nimport {\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n} from '../type/introspection.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport {\n  collectFields,\n  collectSubfields as _collectSubfields,\n} from './collectFields.mjs';\nimport { getArgumentValues, getVariableValues } from './values.mjs';\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) =>\n  _collectSubfields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    returnType,\n    fieldNodes,\n  ),\n);\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport function execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const { schema, document, variableValues, rootValue } = args; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n  try {\n    const { operation } = exeContext;\n    const result = executeOperation(exeContext, operation, rootValue);\n\n    if (isPromise(result)) {\n      return result.then(\n        (data) => buildResponse(data, exeContext.errors),\n        (error) => {\n          exeContext.errors.push(error);\n          return buildResponse(null, exeContext.errors);\n        },\n      );\n    }\n\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function executeSync(args) {\n  const result = execute(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0\n    ? {\n        data,\n      }\n    : {\n        errors,\n        data,\n      };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\nexport function assertValidExecutionArguments(\n  schema,\n  document,\n  rawVariableValues,\n) {\n  document || devAssert(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  assertValidSchema(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null ||\n    isObjectLike(rawVariableValues) ||\n    devAssert(\n      false,\n      'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.',\n    );\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\nexport function buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe, _options$maxCoercionE;\n\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver,\n    options,\n  } = args;\n  let operation;\n  const fragments = Object.create(null);\n\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [\n              new GraphQLError(\n                'Must provide operation name if query contains multiple operations.',\n              ),\n            ];\n          }\n\n          operation = definition;\n        } else if (\n          ((_definition$name = definition.name) === null ||\n          _definition$name === void 0\n            ? void 0\n            : _definition$name.value) === operationName\n        ) {\n          operation = definition;\n        }\n\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(`Unknown operation named \"${operationName}\".`)];\n    }\n\n    return [new GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const variableDefinitions =\n    (_operation$variableDe = operation.variableDefinitions) !== null &&\n    _operation$variableDe !== void 0\n      ? _operation$variableDe\n      : [];\n  const coercedVariableValues = getVariableValues(\n    schema,\n    variableDefinitions,\n    rawVariableValues !== null && rawVariableValues !== void 0\n      ? rawVariableValues\n      : {},\n    {\n      maxErrors:\n        (_options$maxCoercionE =\n          options === null || options === void 0\n            ? void 0\n            : options.maxCoercionErrors) !== null &&\n        _options$maxCoercionE !== void 0\n          ? _options$maxCoercionE\n          : 50,\n    },\n  );\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver:\n      fieldResolver !== null && fieldResolver !== void 0\n        ? fieldResolver\n        : defaultFieldResolver,\n    typeResolver:\n      typeResolver !== null && typeResolver !== void 0\n        ? typeResolver\n        : defaultTypeResolver,\n    subscribeFieldResolver:\n      subscribeFieldResolver !== null && subscribeFieldResolver !== void 0\n        ? subscribeFieldResolver\n        : defaultFieldResolver,\n    errors: [],\n  };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      `Schema is not configured to execute ${operation.operation} operation.`,\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = collectFields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const path = undefined;\n\n  switch (operation.operation) {\n    case OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n\n    case OperationTypeNode.MUTATION:\n      return executeFieldsSerially(\n        exeContext,\n        rootType,\n        rootValue,\n        path,\n        rootFields,\n      );\n\n    case OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\n\nfunction executeFieldsSerially(\n  exeContext,\n  parentType,\n  sourceValue,\n  path,\n  fields,\n) {\n  return promiseReduce(\n    fields.entries(),\n    (results, [responseName, fieldNodes]) => {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result === undefined) {\n        return results;\n      }\n\n      if (isPromise(result)) {\n        return result.then((resolvedResult) => {\n          results[responseName] = resolvedResult;\n          return results;\n        });\n      }\n\n      results[responseName] = result;\n      return results;\n    },\n    Object.create(null),\n  );\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = Object.create(null);\n  let containsPromise = false;\n\n  try {\n    for (const [responseName, fieldNodes] of fields.entries()) {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result !== undefined) {\n        results[responseName] = result;\n\n        if (isPromise(result)) {\n          containsPromise = true;\n        }\n      }\n    }\n  } catch (error) {\n    if (containsPromise) {\n      // Ensure that any promises returned by other fields are handled, as they may also reject.\n      return promiseForObject(results).finally(() => {\n        throw error;\n      });\n    }\n\n    throw error;\n  } // If there are no promises, we can just return the object\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n  return promiseForObject(results);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn =\n    (_fieldDef$resolve = fieldDef.resolve) !== null &&\n    _fieldDef$resolve !== void 0\n      ? _fieldDef$resolve\n      : exeContext.fieldResolver;\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    parentType,\n    path,\n  ); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = getArgumentValues(\n      fieldDef,\n      fieldNodes[0],\n      exeContext.variableValues,\n    ); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue;\n    const result = resolveFn(source, args, contextValue, info);\n    let completed;\n\n    if (isPromise(result)) {\n      completed = result.then((resolved) =>\n        completeValue(exeContext, returnType, fieldNodes, info, path, resolved),\n      );\n    } else {\n      completed = completeValue(\n        exeContext,\n        returnType,\n        fieldNodes,\n        info,\n        path,\n        result,\n      );\n    }\n\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, (rawError) => {\n        const error = locatedError(rawError, fieldNodes, pathToArray(path));\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    const error = locatedError(rawError, fieldNodes, pathToArray(path));\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\nexport function buildResolveInfo(\n  exeContext,\n  fieldDef,\n  fieldNodes,\n  parentType,\n  path,\n) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues,\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (isNonNullType(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n  if (isNonNullType(returnType)) {\n    const completed = completeValue(\n      exeContext,\n      returnType.ofType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n\n    if (completed === null) {\n      throw new Error(\n        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`,\n      );\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n  if (isListType(returnType)) {\n    return completeListValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is Object, execute and complete all sub-selections.\n\n  if (isObjectType(returnType)) {\n    return completeObjectValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n  false ||\n    invariant(\n      false,\n      'Cannot complete value of unexpected output type: ' + inspect(returnType),\n    );\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\nfunction completeListValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  if (!isIterableObject(result)) {\n    throw new GraphQLError(\n      `Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`,\n    );\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result, (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = addPath(path, index, undefined);\n\n    try {\n      let completedItem;\n\n      if (isPromise(item)) {\n        completedItem = item.then((resolved) =>\n          completeValue(\n            exeContext,\n            itemType,\n            fieldNodes,\n            info,\n            itemPath,\n            resolved,\n          ),\n        );\n      } else {\n        completedItem = completeValue(\n          exeContext,\n          itemType,\n          fieldNodes,\n          info,\n          itemPath,\n          item,\n        );\n      }\n\n      if (isPromise(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, (rawError) => {\n          const error = locatedError(\n            rawError,\n            fieldNodes,\n            pathToArray(itemPath),\n          );\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\nfunction completeLeafValue(returnType, result) {\n  const serializedResult = returnType.serialize(result);\n\n  if (serializedResult == null) {\n    throw new Error(\n      `Expected \\`${inspect(returnType)}.serialize(${inspect(result)})\\` to ` +\n        `return non-nullable value, returned: ${inspect(serializedResult)}`,\n    );\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\nfunction completeAbstractValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  var _returnType$resolveTy;\n\n  const resolveTypeFn =\n    (_returnType$resolveTy = returnType.resolveType) !== null &&\n    _returnType$resolveTy !== void 0\n      ? _returnType$resolveTy\n      : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if (isPromise(runtimeType)) {\n    return runtimeType.then((resolvedRuntimeType) =>\n      completeObjectValue(\n        exeContext,\n        ensureValidRuntimeType(\n          resolvedRuntimeType,\n          exeContext,\n          returnType,\n          fieldNodes,\n          info,\n          result,\n        ),\n        fieldNodes,\n        info,\n        path,\n        result,\n      ),\n    );\n  }\n\n  return completeObjectValue(\n    exeContext,\n    ensureValidRuntimeType(\n      runtimeType,\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      result,\n    ),\n    fieldNodes,\n    info,\n    path,\n    result,\n  );\n}\n\nfunction ensureValidRuntimeType(\n  runtimeTypeName,\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  result,\n) {\n  if (runtimeTypeName == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`,\n      fieldNodes,\n    );\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n  if (isObjectType(runtimeTypeName)) {\n    throw new GraphQLError(\n      'Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.',\n    );\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\n        `value ${inspect(result)}, received \"${inspect(runtimeTypeName)}\".`,\n    );\n  }\n\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(\n      `Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\nfunction completeObjectValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  // Collect sub-fields to execute to complete this value.\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then((resolvedIsTypeOf) => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return executeFields(\n          exeContext,\n          returnType,\n          result,\n          path,\n          subFieldNodes,\n        );\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new GraphQLError(\n    `Expected value of type \"${returnType.name}\" but got: ${inspect(result)}.`,\n    {\n      nodes: fieldNodes,\n    },\n  );\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\nexport const defaultTypeResolver = function (\n  value,\n  contextValue,\n  info,\n  abstractType,\n) {\n  // First, look for `__typename`.\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        if (promisedIsTypeOfResults.length) {\n          // Explicitly ignore any promise rejections\n          Promise.allSettled(promisedIsTypeOfResults)\n            /* c8 ignore next 3 */\n            .catch(() => {\n              // Do nothing\n            });\n        }\n\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexport const defaultFieldResolver = function (\n  source,\n  args,\n  contextValue,\n  info,\n) {\n  // ensure source is a value for which property access is acceptable.\n  if (isObjectLike(source) || typeof source === 'function') {\n    const property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\nexport function getFieldDef(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n\n  if (\n    fieldName === SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return SchemaMetaFieldDef;\n  } else if (\n    fieldName === TypeMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}\n","/**\n * Returns true if the value acts like a Promise, i.e. has a \"then\" function,\n * otherwise returns false.\n */\nexport function isPromise(value) {\n  return (\n    typeof (value === null || value === void 0 ? void 0 : value.then) ===\n    'function'\n  );\n}\n","/**\n * Memoizes the provided three-argument function.\n */\nexport function memoize3(fn) {\n  let cache0;\n  return function memoized(a1, a2, a3) {\n    if (cache0 === undefined) {\n      cache0 = new WeakMap();\n    }\n\n    let cache1 = cache0.get(a1);\n\n    if (cache1 === undefined) {\n      cache1 = new WeakMap();\n      cache0.set(a1, cache1);\n    }\n\n    let cache2 = cache1.get(a2);\n\n    if (cache2 === undefined) {\n      cache2 = new WeakMap();\n      cache1.set(a2, cache2);\n    }\n\n    let fnResult = cache2.get(a3);\n\n    if (fnResult === undefined) {\n      fnResult = fn(a1, a2, a3);\n      cache2.set(a3, fnResult);\n    }\n\n    return fnResult;\n  };\n}\n","/**\n * This function transforms a JS object `ObjMap<Promise<T>>` into\n * a `Promise<ObjMap<T>>`\n *\n * This is akin to bluebird's `Promise.props`, but implemented only using\n * `Promise.all` so it will work with any implementation of ES6 promises.\n */\nexport function promiseForObject(object) {\n  return Promise.all(Object.values(object)).then((resolvedValues) => {\n    const resolvedObject = Object.create(null);\n\n    for (const [i, key] of Object.keys(object).entries()) {\n      resolvedObject[key] = resolvedValues[i];\n    }\n\n    return resolvedObject;\n  });\n}\n","import { isPromise } from './isPromise.mjs';\n\n/**\n * Similar to Array.prototype.reduce(), however the reducing callback may return\n * a Promise, in which case reduction will continue after each promise resolves.\n *\n * If the callback does not return a Promise, then this function will also not\n * return a Promise.\n */\nexport function promiseReduce(values, callbackFn, initialValue) {\n  let accumulator = initialValue;\n\n  for (const value of values) {\n    accumulator = isPromise(accumulator)\n      ? accumulator.then((resolved) => callbackFn(resolved, value))\n      : callbackFn(accumulator, value);\n  }\n\n  return accumulator;\n}\n","import { inspect } from './inspect.mjs';\n/**\n * Sometimes a non-error is thrown, wrap it as an Error instance to ensure a consistent Error interface.\n */\n\nexport function toError(thrownValue) {\n  return thrownValue instanceof Error\n    ? thrownValue\n    : new NonErrorThrown(thrownValue);\n}\n\nclass NonErrorThrown extends Error {\n  constructor(thrownValue) {\n    super('Unexpected error value: ' + inspect(thrownValue));\n    this.name = 'NonErrorThrown';\n    this.thrownValue = thrownValue;\n  }\n}\n","import { toError } from '../jsutils/toError.mjs';\nimport { GraphQLError } from './GraphQLError.mjs';\n/**\n * Given an arbitrary value, presumably thrown while attempting to execute a\n * GraphQL operation, produce a new GraphQLError aware of the location in the\n * document responsible for the original Error.\n */\n\nexport function locatedError(rawOriginalError, nodes, path) {\n  var _nodes;\n\n  const originalError = toError(rawOriginalError); // Note: this uses a brand-check to support GraphQL errors originating from other contexts.\n\n  if (isLocatedGraphQLError(originalError)) {\n    return originalError;\n  }\n\n  return new GraphQLError(originalError.message, {\n    nodes:\n      (_nodes = originalError.nodes) !== null && _nodes !== void 0\n        ? _nodes\n        : nodes,\n    source: originalError.source,\n    positions: originalError.positions,\n    path,\n    originalError,\n  });\n}\n\nfunction isLocatedGraphQLError(error) {\n  return Array.isArray(error.path);\n}\n","import { devAssert } from './jsutils/devAssert.mjs';\nimport { isPromise } from './jsutils/isPromise.mjs';\nimport { parse } from './language/parser.mjs';\nimport { validateSchema } from './type/validate.mjs';\nimport { validate } from './validation/validate.mjs';\nimport { execute } from './execution/execute.mjs';\n/**\n * This is the primary entry point function for fulfilling GraphQL operations\n * by parsing, validating, and executing a GraphQL document along side a\n * GraphQL schema.\n *\n * More sophisticated GraphQL servers, such as those which persist queries,\n * may wish to separate the validation and execution phases to a static time\n * tooling step, and a server runtime step.\n *\n * Accepts either an object with named arguments, or individual arguments:\n *\n * schema:\n *    The GraphQL type system to use when validating and executing a query.\n * source:\n *    A GraphQL language formatted string representing the requested operation.\n * rootValue:\n *    The value provided as the first argument to resolver functions on the top\n *    level type (e.g. the query object type).\n * contextValue:\n *    The context value is provided as an argument to resolver functions after\n *    field arguments. It is used to pass shared information useful at any point\n *    during executing this query, for example the currently logged in user and\n *    connections to databases or other services.\n * variableValues:\n *    A mapping of variable name to runtime value to use for all variables\n *    defined in the requestString.\n * operationName:\n *    The name of the operation to use if requestString contains multiple\n *    possible operations. Can be omitted if requestString contains only\n *    one operation.\n * fieldResolver:\n *    A resolver function to use when one is not provided by the schema.\n *    If not provided, the default field resolver is used (which looks for a\n *    value or method on the source value with the field's name).\n * typeResolver:\n *    A type resolver function to use when none is provided by the schema.\n *    If not provided, the default type resolver is used (which looks for a\n *    `__typename` field or alternatively calls the `isTypeOf` method).\n */\n\nexport function graphql(args) {\n  // Always return a Promise for a consistent API.\n  return new Promise((resolve) => resolve(graphqlImpl(args)));\n}\n/**\n * The graphqlSync function also fulfills GraphQL operations by parsing,\n * validating, and executing a GraphQL document along side a GraphQL schema.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function graphqlSync(args) {\n  const result = graphqlImpl(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n\nfunction graphqlImpl(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const {\n    schema,\n    source,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n  } = args; // Validate Schema\n\n  const schemaValidationErrors = validateSchema(schema);\n\n  if (schemaValidationErrors.length > 0) {\n    return {\n      errors: schemaValidationErrors,\n    };\n  } // Parse\n\n  let document;\n\n  try {\n    document = parse(source);\n  } catch (syntaxError) {\n    return {\n      errors: [syntaxError],\n    };\n  } // Validate\n\n  const validationErrors = validate(schema, document);\n\n  if (validationErrors.length > 0) {\n    return {\n      errors: validationErrors,\n    };\n  } // Execute\n\n  return execute({\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n  });\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isAsyncIterable } from '../jsutils/isAsyncIterable.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { collectFields } from './collectFields.mjs';\nimport {\n  assertValidExecutionArguments,\n  buildExecutionContext,\n  buildResolveInfo,\n  execute,\n  getFieldDef,\n} from './execute.mjs';\nimport { mapAsyncIterator } from './mapAsyncIterator.mjs';\nimport { getArgumentValues } from './values.mjs';\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\nexport async function subscribe(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const resultOrStream = await createSourceEventStream(args);\n\n  if (!isAsyncIterable(resultOrStream)) {\n    return resultOrStream;\n  } // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  const mapSourceToResponse = (payload) =>\n    execute({ ...args, rootValue: payload }); // Map every source value to a ExecutionResult value as described above.\n\n  return mapAsyncIterator(resultOrStream, mapSourceToResponse);\n}\n\nfunction toNormalizedArgs(args) {\n  const firstArg = args[0];\n\n  if (firstArg && 'document' in firstArg) {\n    return firstArg;\n  }\n\n  return {\n    schema: firstArg,\n    // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613\n    document: args[1],\n    rootValue: args[2],\n    contextValue: args[3],\n    variableValues: args[4],\n    operationName: args[5],\n    subscribeFieldResolver: args[6],\n  };\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\nexport async function createSourceEventStream(...rawArgs) {\n  const args = toNormalizedArgs(rawArgs);\n  const { schema, document, variableValues } = args; // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  }\n\n  try {\n    const eventStream = await executeSubscription(exeContext); // Assert field returned an event stream, otherwise yield an error.\n\n    if (!isAsyncIterable(eventStream)) {\n      throw new Error(\n        'Subscription field must return Async Iterable. ' +\n          `Received: ${inspect(eventStream)}.`,\n      );\n    }\n\n    return eventStream;\n  } catch (error) {\n    // If it GraphQLError, report it as an ExecutionResult, containing only errors and no data.\n    // Otherwise treat the error as a system-class error and re-throw it.\n    if (error instanceof GraphQLError) {\n      return {\n        errors: [error],\n      };\n    }\n\n    throw error;\n  }\n}\n\nasync function executeSubscription(exeContext) {\n  const { schema, fragments, operation, variableValues, rootValue } =\n    exeContext;\n  const rootType = schema.getSubscriptionType();\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      'Schema is not configured to execute subscription operation.',\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = collectFields(\n    schema,\n    fragments,\n    variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const [responseName, fieldNodes] = [...rootFields.entries()][0];\n  const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    const fieldName = fieldNodes[0].name.value;\n    throw new GraphQLError(\n      `The subscription field \"${fieldName}\" is not defined.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  const path = addPath(undefined, responseName, rootType.name);\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    rootType,\n    path,\n  );\n\n  try {\n    var _fieldDef$subscribe;\n\n    // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n    // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue; // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n    const resolveFn =\n      (_fieldDef$subscribe = fieldDef.subscribe) !== null &&\n      _fieldDef$subscribe !== void 0\n        ? _fieldDef$subscribe\n        : exeContext.subscribeFieldResolver;\n    const eventStream = await resolveFn(rootValue, args, contextValue, info);\n\n    if (eventStream instanceof Error) {\n      throw eventStream;\n    }\n\n    return eventStream;\n  } catch (error) {\n    throw locatedError(error, fieldNodes, pathToArray(path));\n  }\n}\n","/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * implementing a `Symbol.asyncIterator` method.\n */\nexport function isAsyncIterable(maybeAsyncIterable) {\n  return (\n    typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0\n      ? void 0\n      : maybeAsyncIterable[Symbol.asyncIterator]) === 'function'\n  );\n}\n","/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport function mapAsyncIterator(iterable, callback) {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  async function mapResult(result) {\n    if (result.done) {\n      return result;\n    }\n\n    try {\n      return {\n        value: await callback(result.value),\n        done: false,\n      };\n    } catch (error) {\n      /* c8 ignore start */\n      // FIXME: add test case\n      if (typeof iterator.return === 'function') {\n        try {\n          await iterator.return();\n        } catch (_e) {\n          /* ignore error */\n        }\n      }\n\n      throw error;\n      /* c8 ignore stop */\n    }\n  }\n\n  return {\n    async next() {\n      return mapResult(await iterator.next());\n    },\n\n    async return() {\n      // If iterator.return() does not exist, then type R must be undefined.\n      return typeof iterator.return === 'function'\n        ? mapResult(await iterator.return())\n        : {\n            value: undefined,\n            done: true,\n          };\n    },\n\n    async throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return mapResult(await iterator.throw(error));\n      }\n\n      throw error;\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n","import { invariant } from '../../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType, isInputObjectType } from '../../../type/definition.mjs';\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field(node) {\n      const fieldDef = context.getFieldDef();\n      const deprecationReason =\n        fieldDef === null || fieldDef === void 0\n          ? void 0\n          : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        const parentType = context.getParentType();\n        parentType != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    Argument(node) {\n      const argDef = context.getArgument();\n      const deprecationReason =\n        argDef === null || argDef === void 0\n          ? void 0\n          : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        const directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(\n            new GraphQLError(\n              `Directive \"@${directiveDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else {\n          const parentType = context.getParentType();\n          const fieldDef = context.getFieldDef();\n          (parentType != null && fieldDef != null) || invariant(false);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${parentType.name}.${fieldDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        const inputFieldDef = inputObjectDef.getFields()[node.name.value];\n        const deprecationReason =\n          inputFieldDef === null || inputFieldDef === void 0\n            ? void 0\n            : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(\n            new GraphQLError(\n              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    EnumValue(node) {\n      const enumValueDef = context.getEnumValue();\n      const deprecationReason =\n        enumValueDef === null || enumValueDef === void 0\n          ? void 0\n          : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        const enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The enum value \"${enumTypeDef.name}.${enumValueDef.name}\" is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType } from '../../../type/definition.mjs';\nimport { isIntrospectionType } from '../../../type/introspection.mjs';\n\n/**\n * Prohibit introspection queries\n *\n * A GraphQL document is only valid if all fields selected are not fields that\n * return an introspection type.\n *\n * Note: This rule is optional and is not part of the Validation section of the\n * GraphQL Specification. This rule effectively disables introspection, which\n * does not reflect best practices and should only be done if absolutely necessary.\n */\nexport function NoSchemaIntrospectionCustomRule(context) {\n  return {\n    Field(node) {\n      const type = getNamedType(context.getType());\n\n      if (type && isIntrospectionType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `GraphQL introspection has been disabled, but the requested query contained the field \"${node.name.value}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","/**\n * Produce the GraphQL query recommended for a full schema introspection.\n * Accepts optional IntrospectionOptions.\n */\nexport function getIntrospectionQuery(options) {\n  const optionsWithDefault = {\n    descriptions: true,\n    specifiedByUrl: false,\n    directiveIsRepeatable: false,\n    schemaDescription: false,\n    inputValueDeprecation: false,\n    oneOf: false,\n    ...options,\n  };\n  const descriptions = optionsWithDefault.descriptions ? 'description' : '';\n  const specifiedByUrl = optionsWithDefault.specifiedByUrl\n    ? 'specifiedByURL'\n    : '';\n  const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable\n    ? 'isRepeatable'\n    : '';\n  const schemaDescription = optionsWithDefault.schemaDescription\n    ? descriptions\n    : '';\n\n  function inputDeprecation(str) {\n    return optionsWithDefault.inputValueDeprecation ? str : '';\n  }\n\n  const oneOf = optionsWithDefault.oneOf ? 'isOneOf' : '';\n  return `\n    query IntrospectionQuery {\n      __schema {\n        ${schemaDescription}\n        queryType { name kind }\n        mutationType { name kind }\n        subscriptionType { name kind }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ${descriptions}\n          ${directiveIsRepeatable}\n          locations\n          args${inputDeprecation('(includeDeprecated: true)')} {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ${descriptions}\n      ${specifiedByUrl}\n      ${oneOf}\n      fields(includeDeprecated: true) {\n        name\n        ${descriptions}\n        args${inputDeprecation('(includeDeprecated: true)')} {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields${inputDeprecation('(includeDeprecated: true)')} {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ${descriptions}\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ${descriptions}\n      type { ...TypeRef }\n      defaultValue\n      ${inputDeprecation('isDeprecated')}\n      ${inputDeprecation('deprecationReason')}\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                    ofType {\n                      kind\n                      name\n                      ofType {\n                        kind\n                        name\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  `;\n}\n","import { GraphQLError } from '../error/GraphQLError.mjs';\n\n/**\n * Extracts the root type of the operation from the schema.\n *\n * @deprecated Please use `GraphQLSchema.getRootType` instead. Will be removed in v17\n */\nexport function getOperationRootType(schema, operation) {\n  if (operation.operation === 'query') {\n    const queryType = schema.getQueryType();\n\n    if (!queryType) {\n      throw new GraphQLError(\n        'Schema does not define the required query root type.',\n        {\n          nodes: operation,\n        },\n      );\n    }\n\n    return queryType;\n  }\n\n  if (operation.operation === 'mutation') {\n    const mutationType = schema.getMutationType();\n\n    if (!mutationType) {\n      throw new GraphQLError('Schema is not configured for mutations.', {\n        nodes: operation,\n      });\n    }\n\n    return mutationType;\n  }\n\n  if (operation.operation === 'subscription') {\n    const subscriptionType = schema.getSubscriptionType();\n\n    if (!subscriptionType) {\n      throw new GraphQLError('Schema is not configured for subscriptions.', {\n        nodes: operation,\n      });\n    }\n\n    return subscriptionType;\n  }\n\n  throw new GraphQLError(\n    'Can only have query, mutation and subscription operations.',\n    {\n      nodes: operation,\n    },\n  );\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nimport { parse } from '../language/parser.mjs';\nimport { executeSync } from '../execution/execute.mjs';\nimport { getIntrospectionQuery } from './getIntrospectionQuery.mjs';\n/**\n * Build an IntrospectionQuery from a GraphQLSchema\n *\n * IntrospectionQuery is useful for utilities that care about type and field\n * relationships, but do not need to traverse through those relationships.\n *\n * This is the inverse of buildClientSchema. The primary use case is outside\n * of the server context, for instance when doing schema comparisons.\n */\n\nexport function introspectionFromSchema(schema, options) {\n  const optionsWithDefaults = {\n    specifiedByUrl: true,\n    directiveIsRepeatable: true,\n    schemaDescription: true,\n    inputValueDeprecation: true,\n    oneOf: true,\n    ...options,\n  };\n  const document = parse(getIntrospectionQuery(optionsWithDefaults));\n  const result = executeSync({\n    schema,\n    document,\n  });\n  (!result.errors && result.data) || invariant(false);\n  return result.data;\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { parseValue } from '../language/parser.mjs';\nimport {\n  assertInterfaceType,\n  assertNullableType,\n  assertObjectType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isInputType,\n  isOutputType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { introspectionTypes, TypeKind } from '../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../type/scalars.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  (isObjectLike(introspection) && isObjectLike(introspection.__schema)) ||\n    devAssert(\n      false,\n      `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${inspect(\n        introspection,\n      )}.`,\n    ); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = keyValMap(\n    schemaIntrospection.types,\n    (typeIntrospection) => typeIntrospection.name,\n    (typeIntrospection) => buildType(typeIntrospection),\n  ); // Include standard types only if they are used.\n\n  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  const queryType = schemaIntrospection.queryType\n    ? getObjectType(schemaIntrospection.queryType)\n    : null;\n  const mutationType = schemaIntrospection.mutationType\n    ? getObjectType(schemaIntrospection.mutationType)\n    : null;\n  const subscriptionType = schemaIntrospection.subscriptionType\n    ? getObjectType(schemaIntrospection.subscriptionType)\n    : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives\n    ? schemaIntrospection.directives.map(buildDirective)\n    : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      const nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);\n    }\n\n    const type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\n        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`,\n      );\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    const typeStr = inspect(type);\n    throw new Error(\n      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`,\n    );\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL,\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (\n      implementingIntrospection.interfaces === null &&\n      implementingIntrospection.kind === TypeKind.INTERFACE\n    ) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\n        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`,\n      );\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection),\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection),\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\n        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType),\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\n        `Introspection result missing enumValues: ${enumIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(\n        enumIntrospection.enumValues,\n        (valueIntrospection) => valueIntrospection.name,\n        (valueIntrospection) => ({\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason,\n        }),\n      ),\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\n        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),\n      isOneOf: inputObjectIntrospection.isOneOf,\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\n        `Introspection result missing fields: ${inspect(typeIntrospection)}.`,\n      );\n    }\n\n    return keyValMap(\n      typeIntrospection.fields,\n      (fieldIntrospection) => fieldIntrospection.name,\n      buildField,\n    );\n  }\n\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide output type for fields, but received: ${typeStr}.`,\n      );\n    }\n\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\n        `Introspection result missing field args: ${fieldIntrospectionStr}.`,\n      );\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args),\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(\n      inputValueIntrospections,\n      (inputValue) => inputValue.name,\n      buildInputValue,\n    );\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide input type for arguments, but received: ${typeStr}.`,\n      );\n    }\n\n    const defaultValue =\n      inputValueIntrospection.defaultValue != null\n        ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type)\n        : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason,\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive args: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args),\n    });\n  }\n}\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\n/**\n * Sort GraphQLSchema.\n *\n * This function returns a sorted copy of the given GraphQLSchema.\n */\n\nexport function lexicographicSortSchema(schema) {\n  const schemaConfig = schema.toConfig();\n  const typeMap = keyValMap(\n    sortByName(schemaConfig.types),\n    (type) => type.name,\n    sortNamedType,\n  );\n  return new GraphQLSchema({\n    ...schemaConfig,\n    types: Object.values(typeMap),\n    directives: sortByName(schemaConfig.directives).map(sortDirective),\n    query: replaceMaybeType(schemaConfig.query),\n    mutation: replaceMaybeType(schemaConfig.mutation),\n    subscription: replaceMaybeType(schemaConfig.subscription),\n  });\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME: TS Conversion\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function replaceMaybeType(maybeType) {\n    return maybeType && replaceNamedType(maybeType);\n  }\n\n  function sortDirective(directive) {\n    const config = directive.toConfig();\n    return new GraphQLDirective({\n      ...config,\n      locations: sortBy(config.locations, (x) => x),\n      args: sortArgs(config.args),\n    });\n  }\n\n  function sortArgs(args) {\n    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));\n  }\n\n  function sortFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => ({\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && sortArgs(field.args),\n    }));\n  }\n\n  function sortInputFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => ({\n      ...field,\n      type: replaceType(field.type),\n    }));\n  }\n\n  function sortTypes(array) {\n    return sortByName(array).map(replaceNamedType);\n  }\n\n  function sortNamedType(type) {\n    if (isScalarType(type) || isIntrospectionType(type)) {\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      const config = type.toConfig();\n      return new GraphQLObjectType({\n        ...config,\n        interfaces: () => sortTypes(config.interfaces),\n        fields: () => sortFields(config.fields),\n      });\n    }\n\n    if (isInterfaceType(type)) {\n      const config = type.toConfig();\n      return new GraphQLInterfaceType({\n        ...config,\n        interfaces: () => sortTypes(config.interfaces),\n        fields: () => sortFields(config.fields),\n      });\n    }\n\n    if (isUnionType(type)) {\n      const config = type.toConfig();\n      return new GraphQLUnionType({\n        ...config,\n        types: () => sortTypes(config.types),\n      });\n    }\n\n    if (isEnumType(type)) {\n      const config = type.toConfig();\n      return new GraphQLEnumType({\n        ...config,\n        values: sortObjMap(config.values, (value) => value),\n      });\n    }\n\n    if (isInputObjectType(type)) {\n      const config = type.toConfig();\n      return new GraphQLInputObjectType({\n        ...config,\n        fields: () => sortInputFields(config.fields),\n      });\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible types have been considered.\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n}\n\nfunction sortObjMap(map, sortValueFn) {\n  const sortedMap = Object.create(null);\n\n  for (const key of Object.keys(map).sort(naturalCompare)) {\n    sortedMap[key] = sortValueFn(map[key]);\n  }\n\n  return sortedMap;\n}\n\nfunction sortByName(array) {\n  return sortBy(array, (obj) => obj.name);\n}\n\nfunction sortBy(array, mapToKey) {\n  return array.slice().sort((obj1, obj2) => {\n    const key1 = mapToKey(obj1);\n    const key2 = mapToKey(obj2);\n    return naturalCompare(key1, key2);\n  });\n}\n","import { Kind } from '../language/kinds.mjs';\n/**\n * Provided a collection of ASTs, presumably each from different files,\n * concatenate the ASTs together into batched AST, useful for validating many\n * GraphQL source files which together represent one conceptual application.\n */\n\nexport function concatAST(documents) {\n  const definitions = [];\n\n  for (const doc of documents) {\n    definitions.push(...doc.definitions);\n  }\n\n  return {\n    kind: Kind.DOCUMENT,\n    definitions,\n  };\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(\n          definitionNode.selectionSet,\n        );\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  const separatedDocumentASTs = Object.create(null);\n\n  for (const operation of operations) {\n    const dependencies = new Set();\n\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(\n        (node) =>\n          node === operation ||\n          (node.kind === Kind.FRAGMENT_DEFINITION &&\n            dependencies.has(node.name.value)),\n      ),\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    },\n  });\n  return dependencies;\n}\n","import { printBlockString } from '../language/blockString.mjs';\nimport { isPunctuatorTokenKind, Lexer } from '../language/lexer.mjs';\nimport { isSource, Source } from '../language/source.mjs';\nimport { TokenKind } from '../language/tokenKind.mjs';\n/**\n * Strips characters that are not significant to the validity or execution\n * of a GraphQL document:\n *   - UnicodeBOM\n *   - WhiteSpace\n *   - LineTerminator\n *   - Comment\n *   - Comma\n *   - BlockString indentation\n *\n * Note: It is required to have a delimiter character between neighboring\n * non-punctuator tokens and this function always uses single space as delimiter.\n *\n * It is guaranteed that both input and output documents if parsed would result\n * in the exact same AST except for nodes location.\n *\n * Warning: It is guaranteed that this function will always produce stable results.\n * However, it's not guaranteed that it will stay the same between different\n * releases due to bugfixes or changes in the GraphQL specification.\n *\n * Query example:\n *\n * ```graphql\n * query SomeQuery($foo: String!, $bar: String) {\n *   someField(foo: $foo, bar: $bar) {\n *     a\n *     b {\n *       c\n *       d\n *     }\n *   }\n * }\n * ```\n *\n * Becomes:\n *\n * ```graphql\n * query SomeQuery($foo:String!$bar:String){someField(foo:$foo bar:$bar){a b{c d}}}\n * ```\n *\n * SDL example:\n *\n * ```graphql\n * \"\"\"\n * Type description\n * \"\"\"\n * type Foo {\n *   \"\"\"\n *   Field description\n *   \"\"\"\n *   bar: String\n * }\n * ```\n *\n * Becomes:\n *\n * ```graphql\n * \"\"\"Type description\"\"\" type Foo{\"\"\"Field description\"\"\" bar:String}\n * ```\n */\n\nexport function stripIgnoredCharacters(source) {\n  const sourceObj = isSource(source) ? source : new Source(source);\n  const body = sourceObj.body;\n  const lexer = new Lexer(sourceObj);\n  let strippedBody = '';\n  let wasLastAddedTokenNonPunctuator = false;\n\n  while (lexer.advance().kind !== TokenKind.EOF) {\n    const currentToken = lexer.token;\n    const tokenKind = currentToken.kind;\n    /**\n     * Every two non-punctuator tokens should have space between them.\n     * Also prevent case of non-punctuator token following by spread resulting\n     * in invalid token (e.g. `1...` is invalid Float token).\n     */\n\n    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);\n\n    if (wasLastAddedTokenNonPunctuator) {\n      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {\n        strippedBody += ' ';\n      }\n    }\n\n    const tokenBody = body.slice(currentToken.start, currentToken.end);\n\n    if (tokenKind === TokenKind.BLOCK_STRING) {\n      strippedBody += printBlockString(currentToken.value, {\n        minimize: true,\n      });\n    } else {\n      strippedBody += tokenBody;\n    }\n\n    wasLastAddedTokenNonPunctuator = isNonPunctuator;\n  }\n\n  return strippedBody;\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { assertName } from '../type/assertName.mjs';\n/* c8 ignore start */\n\n/**\n * Upholds the spec rules about naming.\n * @deprecated Please use `assertName` instead. Will be removed in v17\n */\n\nexport function assertValidName(name) {\n  const error = isValidNameError(name);\n\n  if (error) {\n    throw error;\n  }\n\n  return name;\n}\n/**\n * Returns an Error if a name is invalid.\n * @deprecated Please use `assertName` instead. Will be removed in v17\n */\n\nexport function isValidNameError(name) {\n  typeof name === 'string' || devAssert(false, 'Expected name to be a string.');\n\n  if (name.startsWith('__')) {\n    return new GraphQLError(\n      `Name \"${name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n    );\n  }\n\n  try {\n    assertName(name);\n  } catch (error) {\n    return error;\n  }\n}\n/* c8 ignore stop */\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nimport { sortValueNode } from './sortValueNode.mjs';\nvar BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] =\n    'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] =\n    'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] =\n    'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] =\n    'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] =\n    'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (BreakingChangeType = {}));\n\nexport { BreakingChangeType };\nvar DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] =\n    'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] =\n    'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (DangerousChangeType = {}));\n\nexport { DangerousChangeType };\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in BreakingChangeType,\n  );\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in DangerousChangeType,\n  );\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [\n    ...findTypeChanges(oldSchema, newSchema),\n    ...findDirectiveChanges(oldSchema, newSchema),\n  ];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(\n    oldSchema.getDirectives(),\n    newSchema.getDirectives(),\n  );\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`,\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`,\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`,\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(\n    Object.values(oldSchema.getTypeMap()),\n    Object.values(newSchema.getTypeMap()),\n  );\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType)\n        ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.`\n        : `${oldType.name} was removed.`,\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (isEnumType(oldType) && isEnumType(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (isUnionType(oldType) && isUnionType(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (isObjectType(oldType) && isObjectType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description:\n          `${oldType.name} changed from ` +\n          `${typeKindName(oldType)} to ${typeKindName(newType)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const newField of fieldsDiff.added) {\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`,\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`,\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldArg.type,\n      newArg.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` +\n          `${String(oldArg.type)} to ${String(newArg.type)}.`,\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`,\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`,\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if (isRequiredArgument(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      (isListType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from nullable to non-null of the same underlying type is safe\n      (isNonNullType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (\n      isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)\n    );\n  }\n\n  return (\n    // if they're both named types, see if their names are equivalent\n    (isNamedType(newType) && oldType.name === newType.name) || // moving from nullable to non-null of the same underlying type is safe\n    (isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (\n      isListType(newType) &&\n      isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      (isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from non-null to nullable of the same underlying type is safe\n      (!isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType))\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  const ast = astFromValue(value, type);\n  ast != null || invariant(false);\n  return print(sortValueNode(ast));\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = keyMap(oldArray, ({ name }) => name);\n  const newMap = keyMap(newArray, ({ name }) => name);\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed,\n  };\n}\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { parseSchemaCoordinate } from '../language/parser.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n} from '../type/definition.mjs';\n\n/**\n * A schema coordinate is resolved in the context of a GraphQL schema to\n * uniquely identify a schema element. It returns undefined if the schema\n * coordinate does not resolve to a schema element, meta-field, or introspection\n * schema element. It will throw if the containing schema element (if\n * applicable) does not exist.\n *\n * https://spec.graphql.org/draft/#sec-Schema-Coordinates.Semantics\n */\nexport function resolveSchemaCoordinate(schema, schemaCoordinate) {\n  return resolveASTSchemaCoordinate(\n    schema,\n    parseSchemaCoordinate(schemaCoordinate),\n  );\n}\n/**\n * TypeCoordinate : Name\n */\n\nfunction resolveTypeCoordinate(schema, schemaCoordinate) {\n  // 1. Let {typeName} be the value of {Name}.\n  const typeName = schemaCoordinate.name.value;\n  const type = schema.getType(typeName); // 2. Return the type in the {schema} named {typeName} if it exists.\n\n  if (type == null) {\n    return;\n  }\n\n  return {\n    kind: 'NamedType',\n    type,\n  };\n}\n/**\n * MemberCoordinate : Name . Name\n */\n\nfunction resolveMemberCoordinate(schema, schemaCoordinate) {\n  // 1. Let {typeName} be the value of the first {Name}.\n  // 2. Let {type} be the type in the {schema} named {typeName}.\n  const typeName = schemaCoordinate.name.value;\n  const type = schema.getType(typeName); // 3. Assert: {type} must exist, and must be an Enum, Input Object, Object or Interface type.\n\n  if (!type) {\n    throw new Error(\n      `Expected ${inspect(typeName)} to be defined as a type in the schema.`,\n    );\n  }\n\n  if (\n    !isEnumType(type) &&\n    !isInputObjectType(type) &&\n    !isObjectType(type) &&\n    !isInterfaceType(type)\n  ) {\n    throw new Error(\n      `Expected ${inspect(\n        typeName,\n      )} to be an Enum, Input Object, Object or Interface type.`,\n    );\n  } // 4. If {type} is an Enum type:\n\n  if (isEnumType(type)) {\n    // 1. Let {enumValueName} be the value of the second {Name}.\n    const enumValueName = schemaCoordinate.memberName.value;\n    const enumValue = type.getValue(enumValueName); // 2. Return the enum value of {type} named {enumValueName} if it exists.\n\n    if (enumValue == null) {\n      return;\n    }\n\n    return {\n      kind: 'EnumValue',\n      type,\n      enumValue,\n    };\n  } // 5. Otherwise, if {type} is an Input Object type:\n\n  if (isInputObjectType(type)) {\n    // 1. Let {inputFieldName} be the value of the second {Name}.\n    const inputFieldName = schemaCoordinate.memberName.value;\n    const inputField = type.getFields()[inputFieldName]; // 2. Return the input field of {type} named {inputFieldName} if it exists.\n\n    if (inputField == null) {\n      return;\n    }\n\n    return {\n      kind: 'InputField',\n      type,\n      inputField,\n    };\n  } // 6. Otherwise:\n  // 1. Let {fieldName} be the value of the second {Name}.\n\n  const fieldName = schemaCoordinate.memberName.value;\n  const field = type.getFields()[fieldName]; // 2. Return the field of {type} named {fieldName} if it exists.\n\n  if (field == null) {\n    return;\n  }\n\n  return {\n    kind: 'Field',\n    type,\n    field,\n  };\n}\n/**\n * ArgumentCoordinate : Name . Name ( Name : )\n */\n\nfunction resolveArgumentCoordinate(schema, schemaCoordinate) {\n  // 1. Let {typeName} be the value of the first {Name}.\n  // 2. Let {type} be the type in the {schema} named {typeName}.\n  const typeName = schemaCoordinate.name.value;\n  const type = schema.getType(typeName); // 3. Assert: {type} must exist, and be an Object or Interface type.\n\n  if (type == null) {\n    throw new Error(\n      `Expected ${inspect(typeName)} to be defined as a type in the schema.`,\n    );\n  }\n\n  if (!isObjectType(type) && !isInterfaceType(type)) {\n    throw new Error(\n      `Expected ${inspect(typeName)} to be an object type or interface type.`,\n    );\n  } // 4. Let {fieldName} be the value of the second {Name}.\n  // 5. Let {field} be the field of {type} named {fieldName}.\n\n  const fieldName = schemaCoordinate.fieldName.value;\n  const field = type.getFields()[fieldName]; // 7. Assert: {field} must exist.\n\n  if (field == null) {\n    throw new Error(\n      `Expected ${inspect(fieldName)} to exist as a field of type ${inspect(\n        typeName,\n      )} in the schema.`,\n    );\n  } // 7. Let {fieldArgumentName} be the value of the third {Name}.\n\n  const fieldArgumentName = schemaCoordinate.argumentName.value;\n  const fieldArgument = field.args.find(\n    (arg) => arg.name === fieldArgumentName,\n  ); // 8. Return the argument of {field} named {fieldArgumentName} if it exists.\n\n  if (fieldArgument == null) {\n    return;\n  }\n\n  return {\n    kind: 'FieldArgument',\n    type,\n    field,\n    fieldArgument,\n  };\n}\n/**\n * DirectiveCoordinate : \\@ Name\n */\n\nfunction resolveDirectiveCoordinate(schema, schemaCoordinate) {\n  // 1. Let {directiveName} be the value of {Name}.\n  const directiveName = schemaCoordinate.name.value;\n  const directive = schema.getDirective(directiveName); // 2. Return the directive in the {schema} named {directiveName} if it exists.\n\n  if (!directive) {\n    return;\n  }\n\n  return {\n    kind: 'Directive',\n    directive,\n  };\n}\n/**\n * DirectiveArgumentCoordinate : \\@ Name ( Name : )\n */\n\nfunction resolveDirectiveArgumentCoordinate(schema, schemaCoordinate) {\n  // 1. Let {directiveName} be the value of the first {Name}.\n  // 2. Let {directive} be the directive in the {schema} named {directiveName}.\n  const directiveName = schemaCoordinate.name.value;\n  const directive = schema.getDirective(directiveName); // 3. Assert {directive} must exist.\n\n  if (!directive) {\n    throw new Error(\n      `Expected ${inspect(\n        directiveName,\n      )} to be defined as a directive in the schema.`,\n    );\n  } // 4. Let {directiveArgumentName} be the value of the second {Name}.\n\n  const {\n    argumentName: { value: directiveArgumentName },\n  } = schemaCoordinate;\n  const directiveArgument = directive.args.find(\n    (arg) => arg.name === directiveArgumentName,\n  ); // 5. Return the argument of {directive} named {directiveArgumentName} if it exists.\n\n  if (!directiveArgument) {\n    return;\n  }\n\n  return {\n    kind: 'DirectiveArgument',\n    directive,\n    directiveArgument,\n  };\n}\n/**\n * Resolves schema coordinate from a parsed SchemaCoordinate node.\n */\n\nexport function resolveASTSchemaCoordinate(schema, schemaCoordinate) {\n  switch (schemaCoordinate.kind) {\n    case Kind.TYPE_COORDINATE:\n      return resolveTypeCoordinate(schema, schemaCoordinate);\n\n    case Kind.MEMBER_COORDINATE:\n      return resolveMemberCoordinate(schema, schemaCoordinate);\n\n    case Kind.ARGUMENT_COORDINATE:\n      return resolveArgumentCoordinate(schema, schemaCoordinate);\n\n    case Kind.DIRECTIVE_COORDINATE:\n      return resolveDirectiveCoordinate(schema, schemaCoordinate);\n\n    case Kind.DIRECTIVE_ARGUMENT_COORDINATE:\n      return resolveDirectiveArgumentCoordinate(schema, schemaCoordinate);\n  }\n}\n"],"names":[],"mappings":"uCAWO,IAAM,EAAc,OAAO,MAAM,CAAC,CACvC,MAAO,GACP,MAAO,GACP,MAAO,EACP,cAAe,IACjB,oBAVuB,qDCNvB,IAAA,EAAA,EAAA,CAAA,CAAA,OAOO,SAAS,EAAgB,CAAW,CAAE,CAAa,EACxD,IAAI,EAAY,KAEhB,IAAK,IAAM,KAAc,EAAY,WAAW,CAC9C,AADgD,GAC5C,EAAW,IAAI,GAAK,EAAA,IAAI,CAAC,oBAAoB,CAAE,CACjD,IAAI,EAEJ,GAAqB,MAAjB,EAAuB,CAIzB,GAAI,EACF,OAAO,EADM,GAIf,EAAY,CACd,MAAO,GACL,AAAC,QAAC,EAAmB,EAAW,IAAA,AAAI,EAEhC,IAFsC,CAEjC,EACL,EAAiB,GAFrB,EAEqB,AAAK,IAAM,EAEhC,OAAO,CAEX,CAGF,IAT2B,AAGrB,GAMC,CACT,CAVkC,sEGrB5B,EFJN,IEGyB,EAAE,AFH3B,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OCAO,SAAS,EAAU,CAAK,EAC7B,MACE,AACA,OADO,kBAAC,EAAqC,KAAK,EAAI,CAApC,CAA0C,IAAA,AAAI,CAGpE,EAH8B,UAAU,KAAK,cDC7C,IAAA,EAAA,EAAA,CAAA,CAAA,OGAO,SAAS,EAAiB,CAAM,EACrC,OAAO,QAAQ,GAAG,CAAC,OAAO,MAAM,CAAC,IAAS,IAAI,CAAE,AAAD,IAC7C,IAAM,EAAiB,OAAO,MAAM,CAAC,MAErC,IAAK,GAAM,CAAC,EAAG,EAAI,GAAI,OAAO,IAAI,CAAC,GAAQ,OAAO,GAAI,AACpD,CAAc,CAAC,EAAI,CAAG,CAAc,CAAC,EAAE,CAGzC,OAAO,CACT,EACF,CHPA,IAAA,EAAA,EAAA,CAAA,CAAA,MKCA,OAAM,UAAuB,MAC3B,YAAY,CAAW,CAAE,CACvB,KAAK,CAAC,2BAA6B,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,IAC3C,IAAI,CAAC,IAAI,CAAG,iBACZ,IAAI,CAAC,WAAW,CAAG,CACrB,CACF,CCTO,SAAS,EAAa,CAAgB,CAAE,CAAK,CAAE,CAAI,MACpD,EAEJ,IAAM,EDLC,aAAuB,CCKR,KAAQ,EDJ1B,AACA,IAAI,YCsBD,AAjBP,CAFiD,EDH1B,CCKnB,EAiBS,OAAO,CAAC,AAjBK,EAiBC,IAAI,EAhBtB,EAGF,IAAI,EAJ+B,AAI/B,YAAY,CAAC,EAAc,OAAO,CAAE,CAC7C,MACE,OAAC,EAAS,EAAc,KAAA,AAAK,EACzB,EACA,EAF+B,AAGrC,OAAQ,CAHqC,CAGvB,CAXoH,KAW9G,CAC5B,GAJwD,KAAK,EAIlD,EAAc,SAAS,MAClC,gBACA,CACF,EACF,mCNfA,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OAOA,EAAA,EAAA,CAAA,CAAA,OAKA,EAAA,EAAA,CAAA,CAAA,MACA,EAAA,EAAA,CAAA,CAAA,OAIA,EAAA,EAAA,CAAA,CAAA,OAOA,IAAM,KAA4B,CAAC,EAAY,EAAY,IACzD,CAAA,EAAA,EADuB,AACvB,gBAAA,AAAiB,EACf,EAAW,MAAM,CACjB,EAAW,SAAS,CACpB,EAAW,cAAc,CACzB,EACA,GEvCK,SAAS,AAAS,CAAE,CAAE,CAAE,CAAE,CAAE,EAC7B,KAAW,QACb,EAAS,CADe,GACX,OAAA,EAGf,IAAI,EAAS,EAAO,GAAG,CAAC,EAET,UAAX,CAAsB,GACxB,EAAS,IAAI,QACb,EAAO,GAAG,CAAC,EAAI,IAGjB,IAAI,EAAS,EAAO,GAAG,CAAC,QAET,IAAX,IACF,EAAS,CADe,GACX,QACb,EAAO,GAAG,CAAC,EAAI,IAGjB,IAAI,EAAW,EAAO,GAAG,CAAC,GAO1B,OALiB,SAAb,EAAwB,EAC1B,EAAW,EAAG,EAAI,EAAI,GACtB,EAAO,GAAG,CAAC,EAAI,IAGV,CACT,GFoDK,SAAS,EAAQ,CAAI,EAE1B,UAAU,MAAM,CAAG,GACjB,CAAA,EAAA,EAAA,SAAS,AAAT,EACE,GACA,uGAEJ,GAAM,QAAE,CAAM,UAAE,CAAQ,gBAAE,CAAc,CAAE,WAAS,CAAE,CAAG,EAExD,EAA8B,EAFgC,AAExB,EAAU,GAGhD,IAAM,EAAa,EAAsB,GAEzC,GAAI,AAL6D,CAGjB,AAE3C,CAAC,WAAY,CAAA,CAAU,CAC1B,EAD6B,IACtB,CACL,OAAQ,CACV,EAaF,GAAI,CACF,CAxBqH,EAwB/G,WAAE,CAAS,AAnBgF,CAmB9E,CAAG,EAChB,EAAS,AAiMnB,SAA0B,AAAjB,CAA2B,CAAE,CAAS,CAAE,CAAS,EACxD,GAzN8I,CAyNxI,EAAW,EAAW,MAAM,CAAC,WAAW,CAAC,EAAU,SAAS,EAElE,GAAgB,MAAM,AAAlB,EACF,MAAM,IAAI,EAAA,YAAY,CACpB,CAAC,oCAAoC,EAAE,EAAU,SAAS,CAAC,WAAW,CAAC,CACvE,CACE,MAAO,CACT,GAIJ,IAAM,EAAa,CAAA,EAAA,EAAA,aAAA,AAAa,EAC9B,EAAW,MAAM,CACjB,EAAW,SAAS,CACpB,EAAW,cAAc,CACzB,EACA,EAAU,YAAY,EAElB,EAEN,KAFa,EAEL,EAAU,SAAS,EACzB,KAAK,EAAA,iBAAiB,CAAC,KAAK,CAC1B,OAAO,EAAc,EAAY,EAAU,EAAW,EAAM,EAE9D,MAAK,EAAA,iBAAiB,CAAC,QAAQ,KAqBjC,EACA,MAGA,EAxBI,AAoBM,EACA,EAGJ,GAxBK,EACL,IACA,EAoBN,EAnBM,EAoBN,EAnBM,EAmBF,EAlBE,CAiBK,CI5VN,AJgWE,SIhWqB,AAAd,CAAoB,CAAE,CAAU,CAAE,CAAY,EAC5D,IAAI,EAAc,EAElB,IAAK,IAAM,KAAS,EAClB,EAAc,EAAU,CADE,EAEtB,EAAY,IAAI,CAAC,AAAC,GAAa,EAAW,EAAU,IACpD,EAAW,EAAa,GAG9B,OAAO,CACT,EJuVI,EAAO,OAAO,GACd,CAAC,EAAS,CAAC,EAAc,EAAW,IAClC,IAAM,EAAY,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EAAM,EAAc,EAAW,IAAI,EACvD,EAAS,EACb,EACA,EACA,EACA,EACA,UAGF,AAAI,KAAW,MACN,EAGL,EAAU,CAJY,EAKjB,EAAO,IADO,AACH,CAAC,AAAC,IAClB,CAAO,CAAC,EAAa,CAAG,EACjB,KAIX,CAAO,CAAC,EAAa,CAAG,EACjB,EACT,EACA,OAAO,MAAM,CAAC,MA5Cd,MAAK,EAAA,iBAAiB,CAAC,YAAY,CAGjC,OAAO,EAAc,EAAY,EAAU,EAAW,EAAM,EAChE,CACF,EAxOoC,EAAY,EAAW,GAEvD,GAAI,EAAU,GACZ,MADqB,CACd,EAAO,IAAI,CAChB,AAAC,GAAS,EAAc,EAAM,EAAW,MAAM,EAC/C,AAAC,IACC,EAAW,MAAM,CAAC,IAAI,CAAC,GAChB,EAAc,KAAM,EAAW,MAAM,IAKlD,OAAO,EAAc,EAAQ,EAAW,MAAM,CAChD,CAAE,MAAO,EAAO,CAEd,OADA,EAAW,MAAM,CAAC,IAAI,CAAC,GAChB,EAAc,KAAM,EAAW,MAAM,CAC9C,CACF,CAOO,SAAS,EAAY,CAAI,EAC9B,IAAM,EAAS,EAAQ,GAEvB,GAAI,CAF0B,CAEhB,GACZ,MADqB,AACf,AAAI,MAAM,6BAHyD,0BAM3E,OAAO,CACT,CAMA,SAAS,EAAc,CAAI,CAAE,CAAM,EACjC,OAAyB,IAAlB,EAAO,MAAM,CAChB,MACE,CACF,EACA,QACE,OACA,CACF,CACN,CAQO,SAAS,EACd,CAAM,CACN,CAAQ,CACR,CAAiB,EAEjB,GAAY,CAAA,EAAA,EAAA,SAAA,AAAS,GAAC,EAAO,0BAE7B,CAFwD,AAExD,EAAA,EAAA,iBAAA,AAAiB,EAAC,GAEG,MAFM,AAE3B,GACE,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,IACb,CAAA,EAAA,EANqH,AAMrH,SAAA,AAAS,GACP,EACA,AANoE,gJAQ1E,CAUO,SAAS,EAAsB,CAAI,MACpC,EAAkB,EAAuB,MAczC,EAZE,QACJ,CAAM,UACN,CAAQ,WACR,CAAS,cACT,CAAY,CACZ,eAAgB,CAAiB,eACjC,CAAa,eACb,CAAa,cACb,CAAY,wBACZ,CAAsB,CACtB,SAAO,CACR,CAAG,EAEE,EAAY,OAAO,MAAM,CAAC,MAEhC,IAAK,IAAM,KAAc,EAAS,WAAW,CAAE,AAC7C,OAAQ,EAAW,IAAI,EACrB,KAAK,EAAA,IAAI,CAAC,oBAAoB,CAC5B,GAAI,AAAiB,QAAM,CACzB,GAAI,KAAc,MAChB,KAD2B,CACpB,CACL,IAAI,EAAA,YAAY,CACd,sEAEH,CAGH,EAAY,CACd,KACE,CAAC,CADI,MACH,EAAmB,EAAW,IAAA,AAAI,EAEhC,IAFsC,CAEjC,EACL,EAAiB,GAFrB,EAE0B,AAAL,IAAW,IAEhC,EAAY,CAAA,EAGd,KAEF,CANI,AAHqB,KAAK,AASzB,EAAA,IAAI,CAAC,mBAAmB,CAC3B,CAAS,CAAC,EAAW,IAAI,CAAC,KAAK,CAAC,CAAG,CAIvC,CAGF,GAAI,CAAC,SACH,AAAqB,EADP,IACV,AAAuB,EAClB,CAAC,IAAI,EAAA,YAAY,CAAC,CAAC,yBAAyB,EAAE,EAAc,EAAE,CAAC,EAAE,CAGnE,CAAC,IAAI,EAAA,YAAY,CAAC,8BAA8B,CAKzD,IAAM,EACJ,MAAC,GAAwB,EAAU,mBAAA,AAAmB,EAElD,EACA,EAHwD,AAGtD,CACF,EAAwB,CAAA,EAAA,EAH5B,AAG4B,iBAAA,AAAiB,EAC7C,EACA,KAL0B,GAM1B,EAN+B,AAO3B,EACA,CAAC,EACL,CACE,UACE,IALkB,GAKjB,EACC,GANwB,KAOpB,IADQ,CACH,EACL,EAAQ,GAFQ,KAN0B,KAAK,EAMnB,EAEpB,AAAiB,EAE3B,CAJmC,CAKnC,EACR,AAJyC,QACrC,EAMN,AAAI,EAAsB,MAAM,CACvB,CADyB,CACH,MAAM,CAG9B,CACL,KAX8B,KAAK,SAYnC,YACA,eACA,YACA,EACA,eAAgB,EAAsB,OAAO,CAC7C,oBACE,EACI,EACA,EACN,YAHoB,CAIlB,OAJ0B,CAKtB,EACA,EACN,KAHmB,QAJ2B,AAInB,KAJwB,WAQjD,CAJ0C,CAKtC,EACA,EAN2C,AAOjD,OAAQ,EAAE,AACZ,CACF,CA2FA,SAAS,CAhGwB,CAgGV,CAAU,CAAE,CAAU,CAAE,CAAW,CAAE,CAAI,AAhGvB,CAgGyB,CAAM,EACtE,IAAM,EAAU,OAAO,MAAM,CAAC,GAjGoC,GAkG9D,EAlGmE,CAkGjD,EAEtB,GAAI,CACF,IAAK,GAAM,CAAC,EAAc,EAAW,GAAI,EAAO,OAAO,GAAI,CACzD,IAAM,EAAY,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EAAM,EAAc,EAAW,IAAI,EACvD,EAAS,EACb,EACA,EACA,EACA,EACA,QAGa,IAAX,IACF,CAAO,CAAC,CADgB,CACH,CAAG,EAEpB,EAAU,KACZ,GAAkB,CADG,AACH,EAGxB,CACF,CAAE,MAAO,EAAO,CACd,GAAI,EAEF,OAAO,EAAiB,GAAS,GAFd,IAEqB,CAAC,KACvC,MAAM,CACR,EAGF,OAAM,CACR,EAAE,MAEF,AAAK,EAME,EANH,AAMoB,GALf,CAMX,CAQA,QAfwB,CAef,EAAa,CAAU,CAAE,CAAU,CAAE,CAAM,CAAE,CAAU,CAAE,CAAI,EACpE,IAAI,EAEJ,IAAM,EAAW,EAAY,EAAW,KApBoB,CAoBd,CAAE,EAAY,CAAU,CAAC,EAAE,EAEzE,GAAI,CAAC,EACH,OAGF,CAJe,GAIT,EAAa,EAAS,IAAI,CAC1B,EACJ,OAAC,EAAoB,EAAS,OAAA,AAAO,EAEjC,EACA,EAHuC,AAG5B,QAFf,KAE4B,CACxB,EAAO,EACX,EACA,EACA,EACA,EACA,GAGF,CAXwB,EAWpB,CAFD,AAMD,EAf2B,EAyBvB,EAVE,EAAO,CAAA,EAAA,EAAA,iBAAiB,AAAjB,EACX,EACA,CAAU,CAAC,EAAE,CACb,EAAW,cAAc,EAKrB,CAJH,CAIkB,EAAW,YAAY,CACtC,EAAS,EAAU,EAAQ,EAAM,EAAc,CAfiC,EAiCtF,GAdE,EADE,EAAU,GACA,EAAO,IADE,AACE,CAAC,AAAC,GACvB,EAAc,EAAY,EAAY,EAAY,EAAM,EAAM,IAGpD,EACV,EACA,EACA,EACA,AAjBwE,EAkBxE,EACA,GAIA,EAAU,GAGZ,OAAO,EAAU,AAHO,IAGH,MAAC,EAAY,AAAD,IAC/B,IAAM,EAAQ,EAAa,EAAU,EAAY,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,IAC7D,OAAO,EAAiB,EAAO,EAAY,EAC7C,GAGF,OAAO,CACT,CAAE,MAAO,EAAU,CAEjB,OAAO,EADO,EAAa,EAAU,EAAY,CAAA,EAAA,EAAA,IACzB,OADoC,AAAX,EAAY,IAC9B,EAAY,EAC7C,CACF,CAKO,SAAS,EACd,CAAU,CACV,CAAQ,CACR,CAAU,CACV,CAAU,CACV,CAAI,EAIJ,MAAO,CACL,UAAW,EAAS,IAAI,YACxB,EACA,WAAY,EAAS,IAAI,YACzB,OACA,EACA,OAAQ,EAAW,MAAM,CACzB,UAAW,EAAW,SAAS,CAC/B,UAAW,EAAW,SAAS,CAC/B,UAAW,EAAW,SAAS,CAC/B,eAAgB,EAAW,cAAc,AAC3C,CACF,CAEA,SAAS,EAAiB,CAAK,CAAE,CAAU,CAAE,CAAU,EAGrD,GAAI,CAAA,EAAA,EAAA,aAAA,AAAa,EAAC,GAChB,MAAM,EAKR,EAN+B,KAK/B,EAAW,MAAM,CAAC,IAAI,CAAC,GAChB,IACT,CAuBA,SAAS,EAAc,CAAU,CAAE,CAAU,CAAE,CAAU,CAAE,CAAI,CAAE,CAAI,CAAE,CAAM,MA8K3E,EACA,IAEA,IAHU,AAGN,EAFM,AAMN,MAQE,EA3LN,GAAI,aAAkB,MACpB,CAD2B,KACrB,EAIR,GAAI,CAAA,EAAA,EAAA,aAAa,AAAb,EAAc,GAAa,CAC7B,IAAM,EAAY,EAChB,EACA,EAAW,MAAM,CACjB,EACA,EACA,EACA,GAGF,GAAkB,MAAM,CAApB,EACF,MAAU,AAAJ,MACJ,CAAC,0CAA0C,EAAE,EAAK,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,EAAK,SAAS,CAAC,CAAC,CAAC,EAI1F,OAAO,CACT,EAAE,MAEF,AAAc,MAAV,AAAgB,EACX,KAGL,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,GAoDjB,AAnDW,SAoDT,AADO,CACG,AArDkB,CAsD5B,CAAU,CACV,CAAU,CACV,CAAI,CACJ,CA/D2D,AA+DvD,CACJ,CAAM,EAEN,GAAI,CAAC,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,GACpB,MAD6B,AACvB,IAAI,EAAA,YAAY,CACpB,CAAC,mDAAmD,EAAE,EAAK,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,EAAK,SAAS,CAAC,EAAE,CAAC,EAKpG,IAAM,EAAW,EAAW,MAAM,CAC9B,EAAkB,GAChB,EAAmB,MAAM,IAAI,CAAC,EAAQ,CAAC,EAAM,KAGjD,IAAM,EAAW,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EAAM,OAAO,GAEtC,GAAI,CACF,IAAI,EAwBJ,GArBE,EADE,EAAU,GACI,EAAK,EADF,EACM,CAAC,AAAC,GACzB,EACE,EACA,EACA,EACA,EACA,EACA,IAIY,EACd,EACA,EACA,EACA,EACA,EACA,GAIA,EAAU,GAIZ,OAHA,GAAkB,EAGX,CAJqB,CAIP,EAHG,EAGC,MAAC,EAAW,AAAC,IACpC,IAAM,EAAQ,EACZ,EACA,EACA,CAAA,EAAA,EAAA,WAAW,AAAX,EAAY,IAEd,OAAO,EAAiB,EAAO,EAAU,EAC3C,GAGF,KAbiG,EAa1F,CACT,CAAE,MAAO,EAAU,CAEjB,OAAO,EADO,EAAa,EAAU,EAAY,CAAA,EAAA,EAAA,IACzB,OADoC,AAAX,EAAY,IAC9B,EAAU,EAC3C,CACF,GACA,OAAO,EAAkB,QAAQ,GAAG,CAAC,GAAoB,CAC3D,EAtHM,EACA,EACA,EACA,EACA,EACA,GAKA,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,GACN,AAiHX,SAAS,AAAkB,CAlHG,AAkHO,CAAE,CAAM,EAC3C,IAAM,EAAmB,EAAW,SAAS,CAAC,GAE9C,GAAwB,MAApB,AAA0B,EAC5B,MAAM,AAAI,MACR,CAAC,WAAW,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAAY,WAAW,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GACpD,KAD4D,OAAO,gCAC9B,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAAA,CADqB,AACF,EAIzE,CAJM,MAIC,CACT,EA5H6B,EAAY,GAInC,CAAA,EAAA,EAAA,cAAc,AAAd,EAAe,MAEf,IACA,EA8HJ,CAjIgC,CAI5B,IACA,EA8HJ,EA7HI,AA2HM,EAEN,AACJ,EA7HI,EAyIJ,AAAI,EAZE,EAUc,CALlB,KAOY,EAPX,EAAwB,EAAW,QAOV,GAPU,AAAW,EAE3C,EACA,EAHiD,AAGtC,QAFf,IAEe,AAAY,EAEK,EADb,EAAW,IACU,QADE,CACY,EAAM,CAJlC,GAOnB,EAPwB,AAOZ,IAAI,CAAC,AAAC,GACvB,EACE,EACA,EACE,EACA,EACA,EACA,EACA,EACA,GAEF,EACA,EACA,EACA,IAKC,EACL,EACA,EACE,EACA,EACA,EACA,EACA,EACA,GAEF,EACA,EACA,EACA,IAtKE,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,GACR,EACL,EACA,EACA,EACA,EAL0B,AAM1B,EACA,OAOF,CAAA,EAAA,EAAA,SAAA,AAAS,GACP,EACA,oDAAsD,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAEpE,CAwJA,SAAS,EACP,CAAe,CACf,CAAU,CACV,CAAU,CACV,CAAU,CACV,CAAI,CACJ,CAAM,EAEN,GAAuB,MAAM,AAAzB,EACF,MAAM,IAAI,EAAA,YAAY,CACpB,CAAC,eAAe,EAAE,EAAW,IAAI,CAAC,uDAAuD,EAAE,EAAK,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,EAAK,SAAS,CAAC,eAAe,EAAE,EAAW,IAAI,CAAC,2GAA2G,CAAC,CAC/Q,GAKJ,GAAI,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,GACf,MAAM,IAAI,EAAA,GADuB,SACX,CACpB,8HAIJ,GAA+B,UAA3B,AAAqC,OAA9B,EACT,MAAM,IAAI,EAAA,YAAY,CACpB,CAAC,eAAe,EAAE,EAAW,IAAI,CAAC,uDAAuD,EAAE,EAAK,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,EAAK,SAAS,CAAC,AAC/H,OADsI,MAChI,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAAQ,YAAY,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAAiB,EAAE,CAAC,AADqE,EAK9I,CAJM,GAIA,EAAc,EAAW,MAAM,CAAC,OAAO,CAAC,GAE9C,GAAmB,MAAM,AAArB,EACF,MAAM,IAAI,EAAA,YAAY,CACpB,CAAC,eAAe,EAAE,EAAW,IAAI,CAAC,0BAA0B,EAAE,EAAgB,wCAAwC,CAAC,CACvH,CACE,MAAO,CACT,GAIJ,GAAI,CAAC,CAAA,EAAA,EAAA,YAAY,AAAZ,EAAa,GAChB,MAAM,IAAI,CADoB,CACpB,YAAY,CACpB,CAAC,eAAe,EAAE,EAAW,IAAI,CAAC,qCAAqC,EAAE,EAAgB,EAAE,CAAC,CAC5F,CACE,MAAO,CACT,GAIJ,GAAI,CAAC,EAAW,MAAM,CAAC,SAAS,CAAC,EAAY,GAC3C,MAAM,IAAI,CAD+C,CAC/C,YAAY,CACpB,CAAC,qBAAqB,EAAE,EAAY,IAAI,CAAC,8BAA8B,EAAE,EAAW,IAAI,CAAC,EAAE,CAAC,CAC5F,CACE,MAAO,CACT,GAIJ,OAAO,CACT,CAKA,SAAS,EACP,CAAU,CACV,CAAU,CACV,CAAU,CACV,CAAI,CACJ,CAAI,CACJ,CAAM,EAGN,IAAM,EAAgB,EAAiB,EAAY,EAAY,GAI/D,GAAI,EAAW,KAJ6D,GAIrD,CAAE,CACvB,IAAM,EAAW,EAAW,QAAQ,CAAC,EAAQ,EAAW,YAAY,CAAE,GAEtE,GAAI,EAAU,GACZ,OAAO,CADgB,CACP,IAAI,AARmH,CAQlH,AAAC,IACpB,GAAI,CAAC,EACH,MAAM,EAAuB,EAAY,EAAQ,GAGnD,CAJuB,MAIhB,EACL,EACA,EACA,EACA,EACA,EAEJ,GAGF,GAAI,CAAC,EACH,MAAM,EADO,AACgB,EAAY,EAAQ,EAErD,CAEA,OAAO,EAAc,EAAY,EAAY,EAAQ,EAAM,EAC7D,CAEA,SAAS,EAAuB,CAAU,CAAE,CAAM,CAAE,CAAU,EAC5D,OAAO,IAAI,EAAA,YAAY,CACrB,CAAC,wBAAwB,EAAE,EAAW,IAAI,CAAC,WAAW,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAAQ,CAAC,CAAC,CAC1E,CACE,MAAO,CACT,EAEJ,CAYO,IAAM,EAAsB,SACjC,CAAK,CACL,CAAY,CACZ,CAAI,CACJ,CAAY,EAGZ,GAAI,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,IAAsC,UAA5B,AAAsC,OAA/B,EAAM,UAAU,CAChD,OAAO,EAAM,UAAU,CAGzB,IAAM,EAAgB,EAAK,MAAM,CAAC,gBAAgB,CAAC,GAC7C,EAA0B,EAAE,CAElC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAc,MAAM,CAAE,IAAK,CAC7C,IAAM,EAAO,CAAa,CAAC,EAAE,CAE7B,GAAI,EAAK,QAAQ,CAAE,CACjB,IAAM,EAAiB,EAAK,QAAQ,CAAC,EAAO,EAAc,GAE1D,GAAI,EAAU,GACZ,CAAuB,CAAC,EAAE,CAAG,OACxB,EAFwB,CAEpB,EAUT,OATI,EAAwB,KADH,CACS,EAEhC,AAFkC,QAE1B,UAAU,CAAC,GAEhB,KAAK,CAAC,KAEP,GAGG,EAAK,IAAI,AAEpB,CARQ,AASV,CAEA,GAAI,EAAwB,MAAM,CAChC,CADkC,MAXN,AAYrB,QAAQ,GAAG,CAAC,GAAyB,IAAI,CAAC,AAAC,IAChD,IAAK,IAAI,EAAI,EAAG,EAAI,EAAgB,MAAM,CAAE,IAAK,AAC/C,GAAI,CAAe,CAAC,EAAE,CACpB,CADsB,MACf,CAAa,CAAC,EAAE,CAAC,IAAI,AAGlC,EAEJ,EAQa,EAAuB,SAClC,CAAM,CACN,CAAI,CACJ,CAAY,CACZ,CAAI,EAGJ,GAAI,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,IAA6B,YAAlB,OAAO,EAAuB,CACxD,IAAM,EAAW,CAAM,CAAC,EAAK,SAAS,CAAC,OAEf,AAAxB,YAAoC,AAAhC,OAAO,EACF,CAAM,CAAC,EAAK,SAAS,CAAC,CAAC,EAAM,EAAc,GAG7C,CACT,CACF,EAaO,SAAS,EAAY,CAAM,CAAE,CAAU,CAAE,CAAS,EACvD,IAAM,EAAY,EAAU,IAAI,CAAC,KAAK,QAEtC,AACE,IAAc,EAAA,kBAAkB,CAAC,IAAI,EACrC,EAAO,YAAY,KAAO,EAEnB,EAAA,QADP,UACyB,CAEzB,IAAc,EAAA,gBAAgB,CAAC,IAAI,EACnC,EAAO,YAAY,KAAO,EAEnB,EAAA,QADP,QACuB,CACd,IAAc,EAAA,oBAAoB,CAAC,IAAI,CACzC,CAD2C,CAC3C,oBAAoB,CAGtB,EAAW,SAAS,EAAE,CAAC,EAAU,AAC1C,iRsB7+BI,EA2BA,ef/CJ,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,MACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,MACA,EAAA,EAAA,CAAA,CAAA,MACA,EAAA,EAAA,CAAA,CAAA,OAyCO,SAAS,EAAQ,CAAI,EAE1B,OAAO,IAAI,QAAQ,AAAC,GAAY,EAAQ,EAAY,IACtD,CAQO,SAAS,EAAY,CAAI,EAC9B,IAAM,EAAS,EAAY,GAE3B,GAAI,CAAA,AAF8B,EAE9B,EAAA,SAAA,AAAS,EAAC,GACZ,MADqB,AACf,AAAI,MAAM,eAH6D,wCAM/E,OAAO,CACT,CAEA,SAAS,EAAY,CAAI,MA0BnB,EAxBJ,UAAU,MAAM,CAAG,GACjB,CAAA,EAAA,EAAA,SAAS,AAAT,GACE,EACA,uGAEJ,GAAM,QACJ,CAAM,QACN,CAAM,WACN,CAAS,cACT,CAAY,gBACZ,CAAc,eACd,CAAa,eACb,CAAa,CACb,cAAY,CACb,CAAG,EAEE,EAAyB,CAAA,CAFrB,CAEqB,EAAA,cAAA,AAAc,CAFjB,CAEkB,GAE9C,GAAI,EAAuB,MAAM,CAAG,EAClC,CADqC,KAC9B,CACL,OAAQ,CACV,EAKF,GAAI,CACF,EAAW,CAAA,EAAA,EAAA,KAAA,AAAK,EAAC,EACnB,CAAE,MAAO,EAAa,CACpB,MAAO,CACL,OAAQ,CAAC,EAAY,AACvB,CACF,CAEA,CAFE,GAEI,EAAmB,CAAA,EAAA,EAAA,CAFZ,OAEY,AAAQ,EAAC,EAAQ,UAEtC,AAAJ,EAAqB,MAAM,CAAG,EACrB,CADwB,AAE7B,OAAQ,CACV,EAGK,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,CACb,kBACA,EACA,yBACA,iBACA,gBACA,gBACA,eACA,CACF,EACF,yPCxHA,EAAA,EAAA,CAAA,CAAA,OCGO,SAAS,EAAgB,CAAkB,EAChD,MAGoD,YAFlD,OAAO,MAAC,EACJ,KAAK,EACL,CAAkB,CAAC,OAAO,KAFC,QAAQ,CAEI,AAAC,CAEhD,CDPA,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,CCEkE,CDFlE,CAAA,CAAA,ECEuE,KDDvE,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OAgCO,eAAe,EAAU,CAAI,EAElC,UAAU,MAAM,CAAG,GACjB,CAAA,EAAA,EAAA,SAAA,AAAS,GACP,EACA,uGAEJ,IAAM,EAAiB,MAAM,EAAwB,GAErD,GAAI,CAAC,EAAgB,GACnB,OAAO,EE3CT,IAAM,CF0CgC,CE1CrB,AFsDO,CEtDC,CAAC,OAAO,OFsDO,MEtDM,CAAC,GAE/C,eAAe,EAAU,CAAM,EAC7B,GAAI,EAAO,IAAI,CACb,CADe,MACR,EAGT,GAAI,KF4CuB,EE3CzB,MAAO,CACL,MAAO,MAAM,GAAS,EAAO,KAAK,CF2CtC,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,CAAE,GAAG,CAAI,CAAE,UAAW,CAAQ,IAAI,AE1CtC,MAAM,CACR,CACF,CAAE,MAAO,EAAO,CAGd,GAAI,AAA2B,YAAY,OAAhC,EAAS,MAAM,CACxB,GAAI,CACF,MAAM,EAAS,MAAM,EACvB,CAAE,EFkC4G,IElCrG,EAAI,CAEb,CAGF,MAAM,CAER,CACF,CAEA,MAAO,CACC,KAAN,SACS,EAAU,MAAM,EAAS,IAAI,IAGhC,OAAN,SAEoC,YAA3B,OAAO,EAAS,MAAM,CACzB,EAAU,MAAM,EAAS,MAAM,IAC/B,CACE,WAAO,EACP,MAAM,CACR,EAGN,MAAM,MAAM,CAAK,EACf,GAAI,AAA0B,YAAY,OAA/B,EAAS,KAAK,CACvB,OAAO,EAAU,MAAM,EAAS,KAAK,CAAC,GAGxC,OAAM,CACR,EAEA,CAAC,OAAO,aAAa,CAAC,GACpB,OAAO,IAAI,AACb,CACF,CFCF,CAiDO,eAAe,EAAwB,GAAG,CAAO,QAChD,EA7CF,CAFE,EAAW,CAAI,CA+CR,AA/CS,EAAE,GAER,aAAc,EACrB,EAGF,CACL,KALsC,EAK9B,EAER,SAAU,CAAI,CAAC,EAAE,CACjB,UAAW,CAAI,CAAC,EAAE,CAClB,aAAc,CAAI,CAAC,EAAE,CACrB,eAAgB,AAmCY,CAnCR,CAAC,EAAE,CACvB,cAAe,CAAI,CAAC,EAAE,CACtB,uBAAwB,CAAI,CAAC,EAAE,AACjC,EAiCM,QAAE,CAAM,UAAE,CAAQ,gBAAE,CAAc,CAAE,CAAG,EAG7C,CAAA,EAAA,CAHmD,CAGnD,6BAAA,AAA6B,EAAC,EAAQ,EAAU,GAGhD,IAAM,EAAa,CAAA,EAAA,EAAA,GAH8C,gBAHuD,EAMrG,AAAqB,EAAC,GAEzC,GAAI,CAF4C,AAE3C,AAAC,YAAY,CAAA,CAAU,CAC1B,EAD6B,IACtB,CACL,OAAQ,CACV,EAGF,GAAI,CACF,IAAM,EAAc,MAAM,EAAoB,AAZ8F,CAG3C,EAWjG,GAAI,CAAC,EAAgB,GACnB,CAHyD,KAGnD,AAAI,KADuB,CAG7B,AADF,CACG,uDALuH,EAK7G,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAAa,CAAC,CAAC,EAI1C,OAAO,CACT,CAAE,MAAO,EAAO,CAGd,GAAI,aAAiB,EAAA,YAAY,CAC/B,CADiC,KAC1B,CACL,OAAQ,CAAC,EACX,AADiB,CAInB,OAAM,CACR,CACF,CAEA,eAAe,EAAoB,CAAU,EAC3C,GAAM,QAAE,CAAM,WAAE,CAAS,WAAE,CAAS,gBAAE,CAAc,WAAE,CAAS,CAAE,CAC/D,EACI,EAAW,EAAO,mBAAmB,GAE3C,GAAgB,MAAZ,AAAkB,EACpB,MAAM,IAAI,EAAA,YAAY,CACpB,8DACA,CACE,MAAO,CACT,GAWJ,GAAM,CAAC,EAAc,EAAW,CAAG,IAAI,AAPpB,CAAA,EAAA,EAAA,aAAA,AAAa,EAC9B,EACA,EACA,EACA,EACA,EAAU,YAAY,EAE0B,OAAO,GAAG,CAAC,EAAE,CACzD,EAAW,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,EAAQ,EAAU,CAAU,CAAC,EAAE,EAE5D,GAAI,CAAC,EAAU,CACb,IAAM,EAAY,CAAU,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,AAC1C,OAAM,IAAI,EAAA,YAAY,CACpB,CAAC,wBAAwB,EAAE,EAAU,iBAAiB,CAAC,CACvD,CACE,MAAO,CACT,EAEJ,CAEA,IAAM,EAAO,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,OAAW,EAAc,EAAS,IAAI,EACrD,EAAO,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAC3B,EACA,EACA,EACA,EACA,GAGF,GAAI,CACF,IAAI,EAMJ,IAAM,EAAO,CAAA,EAAA,EAAA,iBAAA,AAAiB,EAAC,EAAU,CAAU,CAAC,EAAE,CAAE,GAIlD,EAAe,EAAW,UAJyC,EAI7B,CAGtC,CAHwC,CAI5C,OAAC,EAAsB,EAAS,SAAA,AAAS,EAErC,EACA,EAAW,AAHgC,QAC/C,cAEqC,CACjC,EAAc,MAAM,CAHA,CAGU,EAAW,EAHhB,AAGsB,EAAc,GAEnE,AAdkJ,GAc9I,AAVkH,aAU3F,MACzB,CADgC,KAC1B,EAGR,OAAO,CACT,CAAE,MAAO,EAAO,CACd,KAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAO,EAAY,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,GACpD,CACF,wfG7NA,GAAA,EAAA,CAAA,CAAA,OAcO,SAAS,GAAuB,CAAO,EAC5C,MAAO,CACL,MAAM,CAAI,EACR,IAAM,EAAW,EAAQ,WAAW,GAC9B,QACJ,EACI,KAAK,EACL,EAAS,EAFA,QAAQ,OAES,CAEhC,GAAI,EAJgC,CAIC,IAJI,EAIzB,EAA2B,CACzC,IAAM,EAAa,EAAQ,aAAa,EAC1B,OAAd,GAAsB,CAAA,EAAA,GAAA,SAAA,AAAS,EAAC,IAChC,EAAQ,WAAW,CACjB,IAAI,EAAA,YAAY,CACd,CAAC,UAAU,EAAE,EAAW,IAAI,CAAC,CAAC,EAAE,EAAS,IAAI,CAAC,gBAAgB,EAAE,EAAA,CAAmB,CACnF,CACE,MAAO,CACT,GAGN,CACF,EAEA,SAAS,CAAI,EACX,IAAM,EAAS,EAAQ,WAAW,GAC5B,QACJ,EACI,KAAK,EACL,EAAO,AAFA,QAAQ,SAES,CAE9B,CAJgC,EAI5B,GAJiC,AAIF,MAArB,EAA2B,CACvC,IAAM,EAAe,EAAQ,YAAY,GAEzC,GAAoB,MAAhB,AAAsB,EACxB,EAAQ,WAAW,CACjB,IAAI,EAAA,YAAY,CACd,CAAC,YAAY,EAAE,EAAa,IAAI,CAAC,YAAY,EAAE,EAAO,IAAI,CAAC,iBAAiB,EAAE,EAAA,CAAmB,CACjG,CACE,MAAO,CACT,QAGC,CACL,IAAM,EAAa,EAAQ,aAAa,GAClC,EAAW,EAAQ,WAAW,EACrB,OAAd,GAAkC,MAAZ,GAAqB,CAAA,EAAA,GAAA,SAAS,AAAT,GAAU,GACtD,EAAQ,WAAW,CACjB,IAAI,EAAA,YAAY,CACd,CAAC,OAAO,EAAE,EAAW,IAAI,CAAC,CAAC,EAAE,EAAS,IAAI,CAAC,YAAY,EAAE,EAAO,IAAI,CAAC,iBAAiB,EAAE,EAAA,CAAmB,CAC3G,CACE,MAAO,CACT,GAGN,CACF,CACF,EAEA,YAAY,CAAI,EACd,IAAM,EAAiB,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAQ,kBAAkB,IAE9D,GAAI,CAAA,EAAA,EAAA,iBAAA,AAAiB,EAAC,GAAiB,CACrC,IAAM,EAAgB,EAAe,SAAS,EAAE,CAAC,EAAK,IAAI,CAAC,KAAK,CAAC,CAC3D,EACJ,QACI,KAAK,EACL,EAAc,CAFA,QAAQ,QAES,AAEZ,MAAM,CAA3B,GACF,AAL4C,EAKpC,GALyC,QAK9B,CACjB,IAAI,EAAA,YAAY,CACd,CAAC,gBAAgB,EAAE,EAAe,IAAI,CAAC,CAAC,EAAE,EAAc,IAAI,CAAC,gBAAgB,EAAE,EAAA,CAAmB,CAClG,CACE,MAAO,CACT,GAIR,CACF,EAEA,UAAU,CAAI,EACZ,IAAM,EAAe,EAAQ,YAAY,GACnC,QACJ,EACI,KAAK,EACL,EAAa,MAFA,QAAQ,GAES,CAEpC,GAAI,GAAqC,MAArB,CAJwB,CAIG,CAC7C,GAL+C,CAKzC,EAAc,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAQ,YAAY,GACrD,AAAe,UAAQ,CAAA,EAAA,GAAA,SAAA,AAAS,GAAC,GACjC,EAAQ,WAAW,CACjB,IAAI,EAAA,YAAY,CACd,CAAC,gBAAgB,EAAE,EAAY,IAAI,CAAC,CAAC,EAAE,EAAa,IAAI,CAAC,iBAAiB,EAAE,EAAA,CAAmB,CAC/F,CACE,MAAO,CACT,GAGN,CACF,CACF,CACF,CCtGO,SAAS,GAAgC,CAAO,EACrD,MAAO,CACL,MAAM,CAAI,EACR,IAAM,EAAO,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAQ,OAAO,IAErC,GAAQ,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,IAC9B,EAAQ,CAD6B,UAClB,CACjB,IAAI,EAAA,YAAY,CACd,CAAC,sFAAsF,EAAE,EAAK,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAC5G,CACE,MAAO,CACT,GAIR,CACF,CACF,kBC3BO,SAAS,GAAsB,CAAO,EAC3C,IAAM,EAAqB,CACzB,cAAc,EACd,eAAgB,GAChB,uBAAuB,EACvB,mBAAmB,EACnB,uBAAuB,EACvB,OAAO,EACP,GAAG,CAAO,AACZ,EACM,EAAe,EAAmB,YAAY,CAAG,cAAgB,GACjE,EAAiB,EAAmB,cAAc,CACpD,iBACA,GACE,EAAwB,EAAmB,qBAAqB,CAClE,eACA,GACE,EAAoB,EAAmB,iBAAiB,CAC1D,EACA,GAEJ,SAAS,EAAiB,CAAG,EAC3B,OAAO,EAAmB,qBAAqB,CAAG,EAAM,EAC1D,CAEA,IAAM,EAAQ,EAAmB,KAAK,CAAG,UAAY,GACrD,MAAO,CAAC;;;QAGF,EAAE,kBAAkB;;;;;;;;;UASlB,EAAE,aAAa;UACf,EAAE,sBAAsB;;cAEpB,EAAE,EAAiB,6BAA6B;;;;;;;;;;MAUxD,EAAE,aAAa;MACf,EAAE,eAAe;MACjB,EAAE,MAAM;;;QAGN,EAAE,aAAa;YACX,EAAE,EAAiB,6BAA6B;;;;;;;;;iBAS3C,EAAE,EAAiB,6BAA6B;;;;;;;;QAQzD,EAAE,aAAa;;;;;;;;;;;MAWjB,EAAE,aAAa;;;MAGf,EAAE,EAAiB,gBAAgB;MACnC,EAAE,EAAiB,qBAAqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA2C5C,CAAC,AACH,kBClIO,SAAS,GAAqB,CAAM,CAAE,CAAS,EACpD,GAA4B,UAAxB,EAAU,SAAS,CAAc,CACnC,IAAM,EAAY,EAAO,YAAY,GAErC,GAAI,CAAC,EACH,MAAM,GADQ,CACJ,EAAA,YAAY,CACpB,uDACA,CACE,MAAO,CACT,GAIJ,OAAO,CACT,CAEA,GAA4B,aAAxB,EAAU,SAAS,CAAiB,CACtC,IAAM,EAAe,EAAO,eAAe,GAE3C,GAAI,CAAC,EACH,MAAM,IAAI,EADO,AACP,YAAY,CAAC,0CAA2C,CAChE,MAAO,CACT,GAGF,OAAO,CACT,CAEA,GAA4B,iBAAxB,EAAU,SAAS,CAAqB,CAC1C,IAAM,EAAmB,EAAO,mBAAmB,GAEnD,GAAI,CAAC,EACH,MAAM,IAAI,EAAA,IADW,QACC,CAAC,8CAA+C,CACpE,MAAO,CACT,GAGF,OAAO,CACT,CAEA,MAAM,IAAI,EAAA,YAAY,CACpB,6DACA,CACE,MAAO,CACT,EAEJ,CCvCO,SAAS,GAAwB,CAAM,CAAE,CAAO,EACrD,IAAM,EAAsB,CAC1B,gBAAgB,EAChB,sBAAuB,GACvB,mBAAmB,EACnB,uBAAuB,EACvB,OAAO,EACP,GAAG,CAAO,AACZ,EACM,EAAW,CAAA,EAAA,EAAA,KAAA,AAAK,EAAC,GAAsB,IACvC,EAAS,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,QACzB,WACA,CACF,GAEA,MADC,CAAC,EAAO,MAAM,EAAI,EAAO,IAAI,EAAK,CAAA,EAAA,GAAA,SAAA,AAAS,GAAC,GACtC,EAAO,IAAI,AACpB,CC5BA,IAAA,GAAA,EAAA,CAAA,CAAA,OACA,GAAA,EAAA,CAAA,CAAA,OAqBA,GAAA,EAAA,CAAA,CAAA,OAcO,SAAS,GAAkB,CAAa,CAAE,CAAO,EACrD,CAAA,EAAA,GAAA,YAAA,AAAY,EAAC,IAAkB,CAAA,EAAA,GAAA,YAAY,AAAZ,EAAa,EAAc,QAAQ,GACjE,CAAA,EAAA,EAAA,SAAA,AAAS,GACP,EACA,CAAC,0JAA0J,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EAClK,GACA,CAAC,CAAC,EAGR,CAFK,GAEC,EAAsB,EAAc,QAAQ,CAE5C,CAF8C,CAEpC,CAAA,EAAA,GAAA,SAAA,AAAS,EACvB,EAAoB,KAAK,CACxB,AAAD,GAAuB,EAAkB,AANU,IAMN,CAC5C,AAAD,GAAuB,AAwFzB,SAAS,CAAU,CAAI,EAErB,GAAY,MAAR,GAA6B,GA/FoF,GA+FjG,EAAK,IAAI,EAAyB,MAAb,AAAmB,EAAd,IAAI,CAGhD,OAAQ,EAAK,IAAI,EACf,KAAK,EAAA,QAAQ,CAAC,MAAM,CAClB,OAyBgB,AAzBT,EAAe,EA0BrB,IAAI,EAAA,SAD8B,QACb,CAAC,CAC3B,KAAM,EAAoB,IAAI,CAC9B,YAAa,EAAoB,WAAW,CAC5C,eAAgB,EAAoB,cAAc,AACpD,EA5BI,MAAK,EAAA,QAAQ,CAAC,MAAM,CAClB,OAAO,AAkDS,EAlDM,EAmDrB,IAAI,EAAA,SAD8B,QACb,CAAC,CAC3B,KAAM,EAAoB,IAAI,CAC9B,YAAa,EAAoB,WAAW,CAC5C,WAAY,IAAM,EAAyB,GAC3C,OAAQ,IAAM,EAAiB,EACjC,EAtDI,MAAK,EAAA,QAAQ,CAAC,SAAS,CACrB,OAAO,AAwDY,EAxDM,EAyDxB,IAAI,EAAA,YADoC,QAChB,CAAC,CAC9B,KAAM,EAAuB,IAAI,CACjC,YAAa,EAAuB,WAAW,CAC/C,WAAY,IAAM,EAAyB,GAC3C,OAAQ,IAAM,EAAiB,EACjC,EA5DI,MAAK,EAAA,QAAQ,CAAC,KAAK,WA+DF,EA9DM,EA+D3B,GAAI,CAAC,EAAmB,QADe,KACF,CAAE,CACrC,IAAM,EAAwB,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EACtC,OAAM,AAAI,MACR,CAAC,4CAA4C,EAAE,EAAsB,CAAC,CAAC,CAE3E,CAEA,OAAO,IAAI,EAAA,gBAAgB,CAAC,CAC1B,KAAM,EAAmB,IAAI,CAC7B,YAAa,EAAmB,WAAW,CAC3C,MAAO,IAAM,EAAmB,aAAa,CAAC,GAAG,CAAC,EACpD,EAxEI,MAAK,EAAA,QAAQ,CAAC,IAAI,KA2EF,EA1EM,EA2E1B,GAAI,CAAC,EAAkB,OADc,GACJ,CAAE,CACjC,IAAM,EAAuB,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EACrC,OAAM,AAAI,MACR,CAAC,yCAAyC,EAAE,EAAqB,CAAC,CAAC,CAEvE,CAEA,OAAO,IAAI,EAAA,eAAe,CAAC,CACzB,KAAM,EAAkB,IAAI,CAC5B,YAAa,EAAkB,WAAW,CAC1C,OAAQ,CAAA,EAAA,GAAA,SAAA,AAAS,EACf,EAAkB,UAAU,CAC5B,AAAC,GAAuB,EAAmB,IAAI,CAC/C,AAAC,IAAwB,CACvB,YAAa,EAAmB,EADV,SACqB,CAC3C,kBAAmB,EAAmB,iBAAiB,CACzD,CAAC,CAEL,EA3FI,MAAK,EAAA,QAAQ,CAAC,YAAY,KA8FH,EA7FM,EA8FjC,GAAI,CAAC,EAAyB,WAAW,CAAE,CACzC,CAFiD,GAE3C,EAA8B,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EAC5C,OAAM,AAAI,MACR,CAAC,0CAA0C,EAAE,EAA4B,CAAC,CAAC,CAE/E,CAEA,OAAO,IAAI,EAAA,sBAAsB,CAAC,CAChC,KAAM,EAAyB,IAAI,CACnC,YAAa,EAAyB,WAAW,CACjD,OAAQ,IAAM,EAAsB,EAAyB,WAAW,EACxE,QAAS,EAAyB,OACpC,AAD2C,EAxGzC,CAGF,IAAM,EAAU,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EACxB,OAAM,AAAI,MACR,CAAC,8HAA8H,EAAE,EAAQ,CAAC,CAAC,EAE/I,EAtHmC,IAGnC,IAAK,IAAM,IAAW,IAAI,CAFvB,CAEuB,oBAAoB,IAAK,EAAA,kBAAkB,CAAC,CAAE,AAClE,CAH6C,AAGtC,CAAC,EAAQ,IAAI,CAAC,EAAE,CACzB,CAAO,CAAC,EAAQ,IAAI,CAAC,CAAG,CAAA,EAI5B,IAAM,EAAY,EAAoB,SAAS,CAC3C,EAAc,EAAoB,SAAS,EAC3C,KACE,EAAe,EAAoB,YAAY,CACjD,EAAc,EAAoB,YAAY,EAC9C,KACE,EAAmB,EAAoB,gBAAgB,CACzD,EAAc,EAAoB,gBAAgB,EAClD,KAGE,CAHI,CAGS,EAAoB,UAAU,CAC7C,EAAoB,UAAU,CAAC,GAAG,CAAC,AA2QvC,SAAS,AAAe,CAAsB,EAC5C,GAAI,CAAC,EAAuB,IAAI,CAAE,CAChC,IAAM,EAA4B,CAAA,EAAA,EAAA,KAjR2C,EAiRpC,AAAP,EAAQ,EAC1C,OAAM,AAAI,MACR,CAAC,6CAA6C,EAAE,EAA0B,CAAC,CAAC,CAEhF,CAEA,GAAI,CAAC,EAAuB,SAAS,CAAE,CACrC,IAAM,EAA4B,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EAC1C,OAAM,AAAI,MACR,CAAC,kDAAkD,EAAE,EAA0B,CAAC,CAAC,CAErF,CAEA,OAAO,IAAI,EAAA,gBAAgB,CAAC,CAC1B,KAAM,EAAuB,IAAI,CACjC,YAAa,EAAuB,WAAW,CAC/C,aAAc,EAAuB,YAAY,CACjD,UAAW,EAAuB,SAAS,CAAC,KAAK,GACjD,KAAM,EAAsB,EAAuB,IAAI,CACzD,EACF,GAhSI,EAAE,CAEN,CAFQ,MAED,IAAI,EAAA,aAAa,CAAC,CACvB,YAAa,EAAoB,WAAW,CAHe,AAI3D,MAAO,EACP,SAAU,EACV,aAAc,EACd,MAAO,OAAO,MAAM,CAAC,cACrB,EACA,kBACE,EAAyC,KAAK,EAAI,EAAQ,CAA9C,QAAQ,EAAiD,AACzE,GAGA,CAHI,MADgC,EAI3B,EAAQ,CAJwB,AAIjB,EACtB,GAAI,EAAQ,IAAI,GAAK,EAAA,QAAQ,CAAC,IAAI,CAAE,CAClC,IAAM,EAAU,EAAQ,MAAM,CAE9B,GAAI,CAAC,EACH,MAAM,AAAI,CADE,KACI,CAR0D,kDAW5E,OAAO,IAAI,EAAA,WAAW,CAAC,EAAQ,GACjC,CAEA,GAAI,EAAQ,IAAI,GAAK,EAAA,QAAQ,CAAC,QAAQ,CAAE,CACtC,IAAM,EAAc,EAAQ,MAAM,CAElC,GAAI,CAAC,EACH,MAAM,AAAI,KADM,CACA,mDAGlB,IAAM,EAAe,EAAQ,GAC7B,OAAO,IAAI,EAAA,cAAc,CAAC,CAAA,EAAA,EAAA,kBAAA,AAAkB,EAAC,GAC/C,CAEA,OAAO,EAAa,EACtB,CAEA,SAAS,EAAa,CAAO,EAC3B,IAAM,EAAW,EAAQ,IAAI,CAE7B,GAAI,CAAC,EACH,MAAM,AAAI,EADG,IACG,CAAC,wBAAwB,EAAE,CAAA,EAAA,EAAA,OAAO,AAAP,EAAQ,GAAS,CAAC,CAAC,EAGhE,IAAM,EAAO,CAAO,CAAC,EAAS,CAE9B,GAAI,CAAC,EACH,IADS,EACH,AAAI,MACR,CAAC,4CAA4C,EAAE,EAAS,mFAAmF,CAAC,EAIhJ,OAAO,CACT,CAEA,SAAS,EAAc,CAAO,EAC5B,MAAO,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,EAAa,GACvC,CAEA,SAAS,EAAiB,CAAO,EAC/B,MAAO,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,EAAa,GAC1C,CA2CA,CA3CE,QA2CO,EAAyB,CAAyB,EAGzD,GAC2C,OAAzC,EAA0B,UAAU,EACpC,EAA0B,IAAI,GAAK,EAAA,QAAQ,CAAC,IAhDe,KAgDN,CAErD,CADA,KACO,EAAE,CAGX,GAAI,CAAC,EAA0B,UAAU,CAAE,CACzC,IAAM,EAA+B,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EAC7C,OAAM,AAAI,MACR,CAAC,yCAAyC,EAAE,EAA6B,CAAC,CAAC,CAE/E,CAEA,OAAO,EAA0B,UAAU,CAAC,GAAG,CAAC,EAClD,CAyEA,SAAS,EAAiB,CAAiB,EACzC,GAAI,CAAC,EAAkB,MAAM,CAC3B,CAD6B,KACvB,AAAI,MACR,CAAC,qCAAqC,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAAmB,CAAC,CAAC,EAIzE,MAAO,CAAA,EAAA,GAAA,SAAA,AAAS,EACd,EAAkB,MAAM,CACxB,AAAC,GAAuB,EAAmB,IAAI,CAC/C,EAEJ,CAEA,SAAS,EAAW,CAAkB,EACpC,IAAM,EAAO,EAAQ,EAAmB,IAAI,EAE5C,GAAI,CAAC,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,GAAO,CACvB,IAAM,EAAU,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EACxB,OAAM,AAAI,MACR,CAAC,iEAAiE,EAAE,EAAQ,CAAC,CAAC,CAElF,CAEA,GAAI,CAAC,EAAmB,IAAI,CAAE,CAC5B,IAAM,EAAwB,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EACtC,OAAM,AAAI,MACR,CAAC,yCAAyC,EAAE,EAAsB,CAAC,CAAC,CAExE,CAEA,MAAO,CACL,YAAa,EAAmB,WAAW,CAC3C,kBAAmB,EAAmB,iBAAiB,MACvD,EACA,KAAM,EAAsB,EAAmB,IAAI,CACrD,CACF,CAEA,SAAS,EAAsB,CAAwB,EACrD,MAAO,CAAA,EAAA,GAAA,SAAA,AAAS,EACd,EACA,AAAC,GAAe,EAAW,IAAI,CAC/B,EAEJ,CAEA,SAAS,EAAgB,CAAuB,EAC9C,IAAM,EAAO,EAAQ,EAAwB,IAAI,EAEjD,GAAI,CAAC,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,GAAO,CACtB,IAAM,EAAU,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EACxB,OAAU,AAAJ,MACJ,CAAC,mEAAmE,EAAE,EAAQ,CAAC,CAAC,CAEpF,CAEA,IAAM,EACoC,MAAxC,EAAwB,YAAY,CAChC,CAAA,EAAA,GAAA,YAAY,AAAZ,EAAa,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAwB,YAAY,EAAG,QAC/D,EACN,MAAO,CACL,YAAa,EAAwB,WAAW,MAChD,eACA,EACA,kBAAmB,EAAwB,iBAAiB,AAC9D,CACF,CAyBF,gCCxWA,GAAA,EAAA,CAAA,CAAA,OA2BO,SAAS,GAAwB,CAAM,QAgClB,IA/B1B,IAAM,CA+B6B,CA/Bd,EAAO,QAAQ,GAC9B,EAAU,CAAA,EAAA,GAAA,SAAS,AAAT,EACd,GAAW,EAAa,KAAK,EAC5B,AAAD,GAAU,EAAK,IAAI,CAgErB,CA/DE,QA+DO,AAAc,CAAI,EACzB,GAAI,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,IAAS,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,GAC5C,IADmD,GAC5C,EAGT,GAAI,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,GAAO,CACtB,IAAM,EAAS,EAAK,QAAQ,GAC5B,OAAO,IAAI,EAAA,iBAAiB,CAAC,CAC3B,GAAG,CAAM,CACT,WAAY,IAAM,EAAU,EAAO,UAAU,EAC7C,OAAQ,IAAM,EAAW,EAAO,MAAM,CACxC,EACF,CAEA,GAAI,CAAA,EAAA,EAAA,eAAA,AAAe,EAAC,GAAO,CACzB,IAAM,EAAS,EAAK,QAAQ,GAC5B,OAAO,IAAI,EAAA,oBAAoB,CAAC,CAC9B,GAAG,CAAM,CACT,WAAY,IAAM,EAAU,EAAO,UAAU,EAC7C,OAAQ,IAAM,EAAW,EAAO,MAAM,CACxC,EACF,CAEA,GAAI,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,GAAO,CACrB,IAAM,EAAS,EAAK,QAAQ,GAC5B,OAAO,IAAI,EAAA,gBAAgB,CAAC,CAC1B,GAAG,CAAM,CACT,MAAO,IAAM,EAAU,EAAO,KAAK,CACrC,EACF,CAEA,GAAI,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,GAAO,CACpB,IAAM,EAAS,EAAK,QAAQ,GAC5B,OAAO,IAAI,EAAA,eAAe,CAAC,CACzB,GAAG,CAAM,CACT,OAAQ,GAAW,EAAO,MAAM,CAAE,AAAC,GAAU,EAC/C,EACF,CAEA,GAAI,CAAA,EAAA,EAAA,iBAAiB,AAAjB,EAAkB,GAAO,CAC3B,IAAM,EAAS,EAAK,QAAQ,GAC5B,OAAO,IAAI,EAAA,sBAAsB,CAAC,CAChC,GAAG,CAAM,CACT,OAAQ,IArDL,AAqDW,GAAgB,EAAO,MArDvB,AAqD6B,CArDlB,AAAC,GAAW,EACvC,GAAG,AADmC,CAC9B,CACR,KAAM,EAAY,EAAM,IAAI,EAC9B,CAAC,CAmDC,EACF,CAIS,CAAA,EAAA,GAAA,SAAA,AAAS,GAAC,EAAO,oBAAsB,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAC1D,GA/GA,OAAO,IAAI,EAAA,aAAa,CAAC,CACvB,GAAG,CAAY,CACf,MAAO,OAAO,MAAM,CAAC,GACrB,WAAY,GAAW,EAAa,UAAU,EAAE,GAAG,CAAC,AA0BtD,SAAS,AAAc,CAAS,EAC9B,IAAM,EAAS,EAAU,QAAQ,GACjC,OAAO,IAAI,EAAA,gBAAgB,CAAC,CAC1B,GAAG,CAAM,CACT,UAAW,GAAO,EAAO,SAAS,CAAE,AAAC,GAAM,GAC3C,KAAM,EAAS,EAAO,IAAI,CAC5B,EACF,GAhCE,OAAO,EAAiB,EAAa,KAAK,QAC1C,UAAU,EAAiB,EAAa,QAAQ,GAqB5B,EAAiB,GApBrC,aAoBO,CApBO,EAAiB,EAAa,YAAY,OAC1D,GAEA,SAAS,EAAY,CAAI,QACvB,AAAI,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,GAEN,IAFa,AAET,EAAA,WAAW,CAAC,EAAY,EAAK,MAAM,GACrC,CAAA,EAAA,EAAA,aAAA,AAAa,EAAC,GAEhB,IAFuB,AAEnB,EAAA,cAAc,CAAC,EAAY,EAAK,MAAM,GAG5C,EAAiB,EAC1B,CAEA,SAAS,EAAiB,CAAI,EAC5B,OAAO,CAAO,CAAC,EAAK,IAAI,CAAC,AAC3B,CAeA,SAAS,EAAS,CAAI,EACpB,OAAO,GAAW,EAAM,AAAC,IAAS,CAAE,CAAH,EAAM,CAAG,CAAE,KAAM,EAAY,EAAI,IAAI,EAAE,CAAC,CAC3E,CAEA,SAAS,EAAW,CAAS,EAC3B,OAAO,GAAW,EAAW,AAAC,IAAW,CACvC,GADsC,AACnC,CAAK,CACR,KAAM,EAAY,EAAM,IAAI,EAC5B,KAAM,EAAM,IAAI,EAAI,EAAS,EAAM,IAAI,EACzC,CAAC,CACH,CASA,SAAS,EAAU,CAAK,EACtB,OAAO,GAAW,GAAO,GAAG,CAAC,EAC/B,CAqDF,CAEA,SAAS,GAAW,CAAG,CAAE,CAAW,EAClC,IAAM,EAAY,OAAO,MAAM,CAAC,MAEhC,IAAK,IAAM,KAAO,OAAO,IAAI,CAAC,GAAK,IAAI,CAAC,GAAA,cAAc,EAAG,AACvD,CAAS,CAAC,EAAI,CAAG,EAAY,CAAG,CAAC,EAAI,EAGvC,OAAO,CACT,CAEA,SAAS,GAAW,CAAK,EACvB,OAAO,GAAO,EAAO,AAAC,GAAQ,EAAI,IAAI,CACxC,CAEA,SAAS,GAAO,CAAK,CAAE,CAAQ,EAC7B,OAAO,EAAM,KAAK,GAAG,IAAI,CAAC,CAAC,EAAM,KAC/B,IAAM,EAAO,EAAS,GAChB,EAAO,EAAS,GACtB,MAAO,CAAA,EAAA,GAAA,cAAA,AAAc,EAAC,EAAM,EAC9B,EACF,yFCpKO,SAAS,GAAU,CAAS,EACjC,IAAM,EAAc,EAAE,CAEtB,IAAK,IAAM,KAAO,EAChB,EAAY,IAAI,EADW,EACP,EAAI,WAAW,EAGrC,MAAO,CACL,KAAM,EAAA,IAAI,CAAC,QAAQ,aACnB,CACF,CACF,CCTO,SAAS,GAAmB,CAAW,EAC5C,IAAM,EAAa,EAAE,CACf,EAAW,OAAO,MAAM,CAAC,MAE/B,CAFsC,GAEjC,IAAM,KAAkB,EAAY,WAAW,CAAE,AACpD,OAAQ,EAAe,IAAI,EACzB,KAAK,EAAA,EAJ+E,EAI3E,CAAC,oBAAoB,CAC5B,EAAW,IAAI,CAAC,GAChB,KAEF,MAAK,EAAA,IAAI,CAAC,mBAAmB,CAC3B,CAAQ,CAAC,EAAe,IAAI,CAAC,KAAK,CAAC,CAAG,GACpC,EAAe,YAAY,CAKjC,CAIF,IAAM,EAAwB,OAAO,MAAM,CAAC,MAE5C,IAAK,IAAM,KAAa,EAAY,CAClC,IAAM,EAAe,IAAI,IAEzB,IAAK,IAAM,KAAgB,GAAoB,EAAU,YAAY,EAAG,CACtE,AAsBN,SAAS,EAA8B,CAAS,CAAE,CAAQ,CAAE,CAAQ,EAClE,GAAI,CAAC,EAAU,GAAG,CAAC,GAAW,CAC5B,EAAU,GAAG,CAAC,GACd,IAAM,EAAgB,CAAQ,CAAC,EAAS,CAExC,QAAsB,IAAlB,EACF,IAAK,CAD0B,GACpB,KAAU,EACnB,EAA8B,EAAW,EAAU,EAGzD,CACF,EAjCoC,CA4BM,CA5BQ,EAAU,GAMxD,CAAqB,CAHC,AAGA,EAHU,IAAI,CAAG,EAAU,IAAI,CAAC,KAAK,CAAG,GAG1B,CAH8B,AAG3B,CACrC,KAAM,EAAA,IAAI,CAAC,QAAQ,CACnB,YAAa,EAAY,WAAW,CAAC,MAAM,CACzC,AAAC,GACC,IAAS,GACR,EAAK,IAAI,EAR2H,CAQtH,EAAA,IAAI,CAAC,mBAAmB,EACrC,EAAa,GAAG,CAAC,EAAK,IAAI,CAAC,KAAK,EAExC,CACF,CAEA,OAAO,CACT,CAiBA,SAAS,GAAoB,CAAY,EACvC,IAAM,EAAe,EAAE,CAMvB,MALA,CAAA,EAAA,EAAA,KAAA,AAAK,EAAC,EAAc,CAClB,eAAe,CAAI,EACjB,EAAa,IAAI,CAAC,EAAK,IAAI,CAAC,KAAK,CACnC,CACF,GACO,CACT,CC/EA,IAAA,GAAA,EAAA,CAAA,CAAA,OAiEO,SAAS,GAAuB,CAAM,EAC3C,IAAM,EAAY,CAAA,EAAA,EAAA,QAAA,AAAQ,EAAC,GAAU,EAAS,IAAI,EAAA,MAAM,CAAC,GACnD,EAAO,EAAU,IAAI,CACrB,EAAQ,IAAI,EAAA,KAAK,CAAC,GACpB,EAAe,GACf,GAAiC,EAErC,KAAO,EAAM,OAAO,GAAG,IAAI,GAAK,EAAA,SAAS,CAAC,GAAG,EAAE,CAC7C,IAAM,EAAe,EAAM,KAAK,CAC1B,EAAY,EAAa,IAAI,CAO7B,EAAkB,CAAC,CAAA,EAAA,EAAA,qBAAA,AAAqB,EAAC,EAAa,IAAI,EAE5D,IACE,GAAmB,EAAa,IAAI,GAAK,EAAA,SAAS,CAAC,IADrB,EACqB,AAAM,EAAE,EAC7D,GAAgB,GAAA,EAIpB,IAAM,EAAY,EAAK,KAAK,CAAC,EAAa,KAAK,CAAE,EAAa,GAAG,EAE7D,IAAc,EAAA,SAAS,CAAC,YAAY,CACtC,CADwC,EACxB,CAAA,EAAA,GAAA,gBAAA,AAAgB,EAAC,EAAa,KAAK,CAAE,CACnD,UAAU,CACZ,GAEA,GAAgB,EAGlB,EAAiC,CACnC,CAEA,OAAO,CACT,mBC7FO,SAAS,GAAgB,CAAI,EAClC,IAAM,EAAQ,GAAiB,GAE/B,GAAI,EACF,KADS,CACH,EAGR,OAAO,CACT,CAMO,SAAS,GAAiB,CAAI,EAGnC,GAFgB,UAAhB,OAAO,GAAqB,CAAA,EAAA,EAAA,SAAA,AAAS,GAAC,EAAO,iCAEzC,EAAK,UAAU,CAAC,MAClB,CADyB,MAClB,IAAI,EAAA,YAAY,CACrB,CAAC,MAAM,EAAE,EAAK,uEAAuE,CAAC,EAI1F,GAAI,CACF,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EACb,CAAE,MAAO,EAAO,CACd,OAAO,CACT,CACF,CCpCA,CDqCA,GCrCA,GAAA,EAAA,CAAA,CAAA,OAiBA,CDoBkB,ECpBlB,EAAA,CAAA,CAAA,MA+CO,SAAS,GAAoB,CAAS,CAAE,CAAS,EAEtD,OAAO,GAAkB,EAAW,GAAW,MAAM,CACnD,AAAC,GAAW,EAAO,IAAI,IAAI,EAE/B,CAMO,SAAS,GAAqB,CAAS,CAAE,CAAS,EAEvD,OAAO,GAAkB,EAAW,GAAW,MAAM,CACnD,AAAC,GAAW,EAAO,IAAI,IAAI,EAE/B,CAEA,SAAS,GAAkB,CAAS,CAAE,CAAS,EAC7C,MAAO,IACF,AA0DP,SAAS,AAAgB,CAAS,CAAE,CAAS,EAC3C,IAAM,EAAgB,EAAE,CAClB,EAAY,GAChB,OAAO,MAAM,CAAC,EAAU,UAAU,IAClC,OAAO,MAAM,CAAC,EAAU,UAAU,KAGpC,IAAK,IAAM,KAAW,EAAU,OAAO,CAAE,AACvC,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,YAAY,CACrC,YAAa,CAAA,EAAA,EAAA,qBAAA,AAAqB,EAAC,GAC/B,CAAC,gBAAgB,EAAE,EAAQ,IAAI,CAAC,kDAAkD,CAAC,CACnF,CAAA,EAAG,EAAQ,IAAI,CAAC,aAAa,CAAC,AACpC,GAGF,IAAK,GAAM,CAAC,EAAS,EAAQ,GAAI,EAAU,SAAS,CAAE,AAChD,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,IAAY,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,GACpC,EAAc,IAAI,CAD4B,GACxB,AAgG5B,SAAS,AAAoB,CAAO,CAAE,CAAO,EAC3C,IAAM,EAAgB,EAAE,CAClB,EAAa,GAAK,EAAQ,SAAS,GAAI,EAAQ,SAAS,IAE9D,IAAK,IAAM,KAAY,EAAW,KAAK,CAAE,AACvC,EAAc,IAAI,CAAC,CACjB,KAAM,EAAoB,mBAAmB,CAC7C,YAAa,CAAA,EAAG,EAAS,IAAI,CAAC,wBAAwB,EAAE,EAAQ,IAAI,CAAC,CAAC,CAAC,AACzE,GAGF,IAAK,IAAM,KAAY,EAAW,OAAO,CAAE,AACzC,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,uBAAuB,CAChD,YAAa,CAAA,EAAG,EAAS,IAAI,CAAC,4BAA4B,EAAE,EAAQ,IAAI,CAAC,CAAC,CAAC,AAC7E,GAGF,OAAO,CACT,EAnHgD,EAAS,IAC1C,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,IAAY,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,GAC7C,EAAc,IAAI,CADqC,GA0E7D,AAzE4B,SAyEE,AAArB,CAA4B,CAAE,CAAO,EAC5C,IAAM,EAAgB,EAAE,CAClB,EAAoB,GAAK,EAAQ,QAAQ,GAAI,EAAQ,QAAQ,IAEnE,IAAK,IAAM,KAAmB,EAAkB,KAAK,CAAE,AACrD,EAAc,IAAI,CAAC,CACjB,KAAM,EAAoB,mBAAmB,CAC7C,YAAa,CAAA,EAAG,EAAgB,IAAI,CAAC,yBAAyB,EAAE,EAAQ,IAAI,CAAC,CAAC,CAAC,AACjF,GAGF,IAAK,IAAM,KAAmB,EAAkB,OAAO,CAAE,AACvD,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,uBAAuB,CAChD,YAAa,CAAA,EAAG,EAAgB,IAAI,CAAC,6BAA6B,EAAE,EAAQ,IAAI,CAAC,CAAC,CACpF,AADqF,GAIvF,OAAO,CACT,EA5FiD,EAAS,IAC3C,CAAA,EAAA,EAAA,iBAAA,AAAiB,EAAC,IAAY,CAAA,EAAA,EAAA,iBAAA,AAAiB,EAAC,GACzD,EAAc,IAAI,CADiD,GAyBzE,AAxB4B,SAwBQ,AAA3B,CAAkC,CAAE,CAAO,EAClD,IAAM,EAAgB,EAAE,CAClB,EAAa,GACjB,OAAO,MAAM,CAAC,EAAQ,SAAS,IAC/B,OAAO,MAAM,CAAC,EAAQ,SAAS,KAGjC,IAAK,IAAM,KAAY,EAAW,KAAK,CAAE,AACnC,CAAA,EAAA,EAAA,oBAAA,AAAoB,EAAC,GACvB,EAAc,IAAI,CAAC,CADe,AAEhC,KAAM,EAAmB,0BAA0B,CACnD,YAAa,CAAC,iBAAiB,EAAE,EAAS,IAAI,CAAC,eAAe,EAAE,EAAQ,IAAI,CAAC,WAAW,CAC1F,AAD2F,GAG3F,EAAc,IAAI,CAAC,CACjB,KAAM,EAAoB,0BAA0B,CACpD,YAAa,CAAC,kBAAkB,EAAE,EAAS,IAAI,CAAC,eAAe,EAAE,EAAQ,IAAI,CAAC,WAAW,CAAC,AAC5F,GAIJ,IAAK,IAAM,KAAY,EAAW,OAAO,CAAE,AACzC,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,aAAa,CACtC,YAAa,CAAA,EAAG,EAAQ,IAAI,CAAC,CAAC,EAAE,EAAS,IAAI,CAAC,aAAa,CAC7D,AAD8D,GAIhE,IAAK,GAAM,CAAC,EAAU,EAAS,GAAI,EAAW,SAAS,CAAE,AACxC,AAKX,CAAC,EAJH,EAAS,IAAI,AAIF,CAHX,EAAS,IAAI,GAIb,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,kBAAkB,CAC3C,YACE,CAAA,EAAG,EAAQ,IAAI,CAAC,CAAC,EAAE,EAAS,IAAI,CAAC,AACjC,mBADoD,AACpD,EAAG,OAAO,EAAS,IAAI,EAAE,IAAI,EAAE,OAAO,EAAS,IAAI,EAAE,CAAC,CADD,AACE,AAC3D,GADI,AAKR,OAAO,CACT,EArEuD,EAAS,IACjD,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,IAAY,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,IAKtC,CAAA,EAAA,EAAA,CALgD,cAKhD,AAAe,EAAC,IAAY,CAAA,EAAA,EAAA,eAAA,AAAe,EAAC,GACrD,EAAc,IAAI,CAD6C,GAgIrE,AA9HW,SA8He,AAAjB,CAAwB,CAAE,CAAO,EACxC,IAAM,EAAgB,EAAE,CAClB,EAAa,GACjB,OAAO,MAAM,CAAC,EAAQ,SAAS,IAC/B,OAAO,MAAM,CAAC,EAAQ,SAAS,KAGjC,IAAK,IAAM,KAAY,EAAW,OAAO,CAAE,AACzC,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,aAAa,CACtC,YAAa,CAAA,EAAG,EAAQ,IAAI,CAAC,CAAC,EAAE,EAAS,IAAI,CAAC,aAAa,CAAC,AAC9D,GAGF,IAAK,GAAM,CAAC,EAAU,EAAS,GAAI,EAAW,SAAS,CAAE,AACvD,EAAc,IAAI,IAAI,AAmB1B,SAAwB,AAAf,CAAsB,CAAE,CAAQ,CAAE,CAAQ,EACjD,IAAM,EAAgB,EAAE,CAClB,EAAW,GAAK,EAAS,IAAI,CAAE,EAAS,IAAI,EAElD,IAAK,IAAM,KAAU,EAAS,OAAO,CAAE,AACrC,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,WAAW,CACpC,YAAa,CAAA,EAAG,EAAQ,IAAI,CAAC,CAAC,EAAE,EAAS,IAAI,CAAC,KAAK,EAAE,EAAO,IAAI,CAAC,aAAa,CAChF,AADiF,GAInF,IAAK,GAAM,CAAC,EAAQ,EAAO,GAAI,EAAS,SAAS,CAAE,AAMjD,GALe,CAKX,CAAC,CAJH,EAAO,IAAI,CACX,AAGW,EAHJ,IAAI,GAUN,GAA4B,SAAxB,EAAO,AAA4B,YAAhB,CAC5B,QAA4B,IAAxB,EAAO,KAA4B,OAAhB,CACrB,EAAc,IAAI,CAAC,CACjB,KAAM,EAAoB,wBAAwB,CAClD,YAAa,CAAA,EAAG,EAAQ,IAAI,CAAC,CAAC,EAAE,EAAS,IAAI,CAAC,KAAK,EAAE,EAAO,IAAI,CAAC,0BAA0B,CAAC,AAC9F,OACK,CAIL,IAAM,EAAc,GAAe,EAAO,YAAY,CAAE,EAAO,IAAI,EAC7D,EAAc,GAAe,EAAO,YAAY,CAAE,EAAO,IAAI,EAE/D,IAAgB,GAClB,EAAc,IAAI,CAAC,CACjB,EAF6B,GAEvB,EAAoB,wBAAwB,CAClD,YAAa,CAAA,EAAG,EAAQ,IAAI,CAAC,CAAC,EAAE,EAAS,IAAI,CAAC,KAAK,EAAE,EAAO,IAAI,CAAC,+BAA+B,EAAE,EAAY,IAAI,EAAE,EAAY,CAAC,CAAC,AACpI,EAEJ,CACF,MA1BE,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,gBAAgB,CACzC,YACE,CAAA,EAAG,EAAQ,IAAI,CAAC,CAAC,EAAE,EAAS,IAAI,CAAC,KAAK,EAAE,EAAO,IAAI,CAAC,AACpD,uBAD2E,AAC3E,EAAG,OAAO,EAAO,IAAI,EAAE,IAAI,EAAE,OAAO,EAAO,IAAI,EAAE,CAAC,CAAC,AACvD,AAFgF,GAC5E,AAyBR,IAAK,IAAM,KAAU,EAAS,KAAK,CAAE,AAC/B,CAAA,EAAA,EAAA,kBAAA,AAAkB,EAAC,GACrB,EAAc,IADgB,AACZ,CAAC,CACjB,KAAM,EAAmB,kBAAkB,CAC3C,YAAa,CAAC,eAAe,EAAE,EAAO,IAAI,CAAC,IAAI,EAAE,EAAQ,IAAI,CAAC,CAAC,EAAE,EAAS,IAAI,CAAC,WAAW,CAAC,AAC7F,GAEA,EAAc,IAAI,CAAC,CACjB,KAAM,EAAoB,kBAAkB,CAC5C,YAAa,CAAC,gBAAgB,EAAE,EAAO,IAAI,CAAC,IAAI,EAAE,EAAQ,IAAI,CAAC,CAAC,EAAE,EAAS,IAAI,CAAC,WAAW,CAAC,AAC9F,GAIJ,OAAO,CACT,EAjFyC,EAAS,EAAU,IAMpD,CALW,AAkFnB,AA7ES,QAAQ,CA6ER,EAAsC,CAAO,CAAE,CAAO,QAC7D,AAAI,CAAA,EAAA,EAAA,UAAU,AAAV,EAAW,GAGV,CAAA,EAAA,EAAA,EAHoB,QAGpB,AAAU,EAAC,IACV,EACE,EAAQ,MAAM,CACd,EAAQ,MAAM,GAEjB,CAAA,EAAA,EAAA,aAAA,AAAa,EAAC,IACb,EAAsC,EAAS,EAAQ,MAAM,EAI/D,CAAA,EAAA,EAAA,aAAA,AAAa,EAAC,GAGd,CAAA,EAAA,EAAA,EAHwB,WAGxB,AAAa,EAAC,IACd,EAAsC,EAAQ,MAAM,CAAE,EAAQ,MAAM,EAMrE,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,IAAY,EAAQ,IAAI,GAAK,EAAQ,IAAI,EACrD,CAAA,EAAA,EAAA,aAAA,AAAa,EAAC,IACb,EAAsC,EAAS,EAAQ,MAAM,CAEnE,EA7GM,EAAS,IAAI,CACb,EAAS,IAAI,GAIb,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,kBAAkB,CAC3C,YACE,CAAA,EAAG,EAAQ,IAAI,CAAC,CAAC,EAAE,EAAS,IAAI,CAAC,AACjC,mBADoD,AACpD,EAAG,OAAO,EAAS,IAAI,EAAE,IAAI,EAAE,OAAO,EAAS,IAAI,EAAE,CAAC,CAAC,AAC3D,AAFyD,GACrD,AAKR,OAAO,CACT,EA9J4B,EAAS,MAC1B,AAwGX,SAA0C,AAAjC,CAAwC,CAAE,CAAO,EACxD,IAAM,EAAgB,EAAE,CAClB,EAAiB,GAAK,EAAQ,aAAa,GAAI,EAAQ,aAAa,IAE1E,IAAK,IAAM,KAAgB,EAAe,KAAK,CAAE,AAC/C,EAAc,IAAI,CAAC,CACjB,KAAM,EAAoB,2BAA2B,CACrD,YAAa,CAAA,EAAG,EAAa,IAAI,CAAC,oCAAoC,EAAE,EAAQ,IAAI,CAAC,CAAC,CAAC,AACzF,GAGF,IAAK,IAAM,KAAgB,EAAe,OAAO,CAAE,AACjD,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,6BAA6B,CACtD,YAAa,CAAA,EAAG,EAAQ,IAAI,CAAC,gCAAgC,EAAE,EAAa,IAAI,CAAC,CAAC,CAAC,AACrF,GAGF,OAAO,CACT,EA3H4C,EAAS,IAEtC,EAAQ,WAAW,GAAK,EAAQ,WAAW,EAAE,AACtD,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,iBAAiB,CAC1C,YACE,CAAA,EAAG,EAAQ,IAAI,CAAC,AAChB,cAAA,AAD8B,EAC3B,GAAa,GAAS,IAAI,EAAE,GAAa,GAAS,CAAC,CAAC,AAC3D,AAFmC,GAMvC,AALQ,OAKD,CACT,EAtGuB,EAAW,MAC3B,AAIP,SAAS,AAAqB,CAAS,CAAE,CAAS,EAChD,IAAM,EAAgB,EAAE,CAClB,EAAiB,GACrB,EAAU,aAAa,GACvB,EAAU,aAAa,IAGzB,IAAK,IAAM,KAAgB,EAAe,OAAO,CAAE,AACjD,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,iBAAiB,CAC1C,YAAa,CAAA,EAAG,EAAa,IAAI,CAAC,aAAa,CAAC,AAClD,GAGF,IAAK,GAAM,CAAC,EAAc,EAAa,GAAI,EAAe,SAAS,CAAE,CACnE,IAAM,EAAW,GAAK,EAAa,IAAI,CAAE,EAAa,IAAI,EAE1D,IAAK,IAAM,KAAU,EAAS,KAAK,CAC7B,AAD+B,AAC/B,CAAA,EAAA,EAAA,kBAAA,AAAkB,EAAC,IACrB,EAAc,GADgB,CACZ,CAAC,CACjB,KAAM,EAAmB,4BAA4B,CACrD,YAAa,CAAC,eAAe,EAAE,EAAO,IAAI,CAAC,cAAc,EAAE,EAAa,IAAI,CAAC,WAAW,CAAC,AAC3F,GAIJ,IAAK,IAAM,KAAU,EAAS,OAAO,CAAE,AACrC,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,qBAAqB,CAC9C,YAAa,CAAA,EAAG,EAAO,IAAI,CAAC,kBAAkB,EAAE,EAAa,IAAI,CAAC,CAAC,CAAC,AACtE,GAUF,IAAK,IAAM,KAPP,EAAa,YAAY,EAAI,CAAC,EAAa,YAAY,EAAE,AAC3D,EAAc,IAAI,CAAC,CACjB,KAAM,EAAmB,4BAA4B,CACrD,YAAa,CAAC,iCAAiC,EAAE,EAAa,IAAI,CAAC,CAAC,CAAC,AACvE,GAGqB,EAAa,SAAS,CAAE,CACzC,AAAC,EAAa,SAAS,CAAC,QAAQ,CAAC,IACnC,EAAc,IAAI,CAAC,AAD2B,CAE5C,KAAM,EAAmB,0BAA0B,CACnD,YAAa,CAAA,EAAG,EAAS,kBAAkB,EAAE,EAAa,IAAI,CAAC,CAAC,CAAC,AACnE,EAGN,CAEA,OAAO,CACT,EAvD4B,EAAW,GACpC,AACH,CAlEE,CADS,EAsBR,IAAuB,EAAqB,CAAC,CAAC,GArB5B,IAAD,CADS,MAsBJ,CArBW,CAAG,eACrC,EAAmB,gBAAD,CAAqB,CAAG,oBAC1C,EAAmB,gBAAD,OAA2B,CAAG,0BAChD,EAAmB,gBAAD,OAA2B,CAAG,0BAChD,EAAmB,gBAAD,UAA8B,CAC9C,6BACF,EAAmB,gBAAD,aAAiC,CACjD,gCACF,EAAmB,aAAgB,CAAG,EAApB,cAClB,EAAmB,gBAAD,EAAsB,CAAG,qBAC3C,EAAmB,gBAAD,EAAsB,CAAG,qBAC3C,EAAmB,WAAc,CAAG,IAAlB,UAClB,EAAmB,gBAAmB,AAApB,CAAuB,mBACzC,EAAmB,gBAAD,CAAqB,CAAG,oBAC1C,EAAmB,gBAAD,KAAyB,CAAG,wBAC9C,EAAmB,gBAAD,YAAgC,CAChD,+BACF,EAAmB,gBAAD,YAAgC,CAChD,+BACF,EAAmB,gBAAD,UAA8B,CAC9C,6BAOF,CADS,EASR,IAAwB,EAAsB,EAAC,CAAC,EAR7B,KAAD,CADS,MASJ,OARkB,CAAG,sBAC7C,EAAoB,iBAAD,EAAuB,CAAG,sBAC7C,EAAoB,iBAAD,SAA8B,CAC/C,6BACF,EAAoB,iBAAD,CAAsB,CAAG,qBAC5C,EAAoB,iBAAD,UAA+B,CAChD,8BACF,EAAoB,iBAAD,OAA4B,CAAG,2BAmXpD,SAAS,GAA0C,CAAO,CAAE,CAAO,QACjE,AAAI,CAAA,EAAA,EAAA,UAAU,AAAV,EAAW,GAGX,CAAA,EAAA,EAAA,EAHqB,QAGrB,AAAU,EAAC,IACX,GAA0C,EAAQ,MAAM,CAAE,EAAQ,MAAM,EAIxE,CAAA,EAAA,EAAA,aAAA,AAAa,EAAC,GAIb,CAAA,EAAA,EAAA,EAJuB,WAIvB,AAAa,EAAC,IACb,GACE,EAAQ,MAAM,CACd,EAAQ,MAAM,GAEjB,CAAC,CAAA,EAAA,EAAA,aAAA,AAAa,EAAC,IACd,GAA0C,EAAQ,MAAM,CAAE,GAIzD,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,IAAY,EAAQ,IAAI,GAAK,EAAQ,IAAI,AAC9D,CAEA,SAAS,GAAa,CAAI,QACxB,AAAI,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,GACR,IADe,YAIpB,CAAA,EAAA,EAAA,YAAY,AAAZ,EAAa,GACR,IADe,aAIpB,CAAA,EAAA,EAAA,eAAA,AAAe,EAAC,GACX,IADkB,gBAIvB,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,GACP,IADc,WAInB,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,GACN,IADa,WAIlB,CAAA,EAAA,EAAA,iBAAA,AAAiB,EAAC,GACb,IADoB,gBAMpB,CAAA,EAAA,GAAA,SAAA,AAAS,GAAC,EAAO,oBAAsB,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAC1D,CAEA,SAAS,GAAe,CAAK,CAAE,CAAI,EACjC,IAAM,EAAM,CAAA,EAAA,GAAA,YAAA,AAAY,EAAC,EAAO,GAEhC,OADA,AAAO,SAAQ,CAAA,EAAA,GAAA,SAAA,AAAS,EAAC,IAClB,CAAA,EAAA,EAAA,KAAA,AAAK,EAAC,CAAA,EAAA,GAAA,aAAA,AAAa,EAAC,GAC7B,CAEA,SAAS,GAAK,CAAQ,CAAE,CAAQ,EAC9B,IAAM,EAAQ,EAAE,CACV,EAAU,EAAE,CACZ,EAAY,EAAE,CACd,EAAS,CAAA,EAAA,GAAA,MAAA,AAAM,EAAC,EAAU,CAAC,CAAE,MAAI,CAAE,GAAK,GACxC,EAAS,CAAA,EAAA,GAAA,MAAA,AAAM,EAAC,EAAU,CAAC,MAAE,CAAI,CAAE,GAAK,GAE9C,IAAK,IAAM,KAAW,EAAU,CAC9B,IAAM,EAAU,CAAM,CAAC,EAAQ,IAAI,CAAC,MAEpB,IAAZ,EACF,EAAQ,GADiB,CACb,CAAC,GAEb,EAAU,IAAI,CAAC,CAAC,EAAS,EAAQ,CAErC,CAEA,IAAK,IAAM,KAAW,OACS,EADC,EAC1B,CAAM,CAAC,EAAQ,GAAqB,CAAjB,CAAC,EACtB,EAAM,IAAI,CAAC,GAIf,MAAO,OACL,YACA,UACA,CACF,CACF,CCnfO,SAAS,GAAwB,CAAM,CAAE,CAAgB,EAC9D,OAAO,GACL,EACA,CAAA,EAAA,EAAA,qBAAqB,AAArB,EAAsB,GAE1B,CAyMO,SAAS,GAA2B,CAAM,CAAE,CAAgB,EACjE,OAAQ,EAAiB,IAAI,EAC3B,KAAK,EAAA,IAAI,CAAC,eAAe,CApM3B,IAAM,EAqMmC,AArMxB,EAAiB,IAAI,CAAC,KAAK,CACtC,EAAO,AAoMoB,EApMb,OAAO,CAAC,GAE5B,GAAY,KAF2B,CAEnC,AAAc,EAIlB,MAAO,CACL,KAAM,iBACN,CACF,QA6LE,MAAK,EAAA,IAAI,CAAC,cAtM+F,GAsM9E,CACzB,OAxLN,AAwLa,SAxLoB,AAAxB,CAA8B,CAAE,CAAgB,EAGvD,IAAM,EAAW,EAAiB,IAAI,CAAC,KAAK,CACtC,EAAO,EAAO,OAAO,CAAC,GAE5B,GAAI,CAAC,EACH,EAHqC,EAE5B,EACC,AAAJ,MACJ,CAAC,SAAS,EAAE,CAAA,EAAA,EAAA,OAAO,AAAP,EAAQ,GAAU,uCAAuC,CAAC,EAI1E,GACE,CAAC,CAAA,EAAA,EAAA,GATiI,OASjI,AAAU,EAAC,IACZ,CAAC,CAAA,EAAA,EAAA,iBAAA,AAAiB,EAAC,IACnB,CAAC,CAAA,EAAA,EAAA,YAAY,AAAZ,EAAa,IACd,CAAC,CAAA,EAAA,EAAA,eAAA,AAAe,EAAC,GAEjB,IADA,EACM,AAAI,MACR,CAAC,SAAS,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EACjB,GACA,uDAAuD,CAAC,EAI9D,GAAI,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,GAAO,CAEpB,IAAM,EAAgB,EAAiB,UAAU,CAAC,KAAK,CACjD,EAAY,EAAK,QAAQ,CAAC,GAEhC,GAAiB,MAAb,AAAmB,EACrB,EAH8C,KAMhD,MAAO,CACL,KAAM,iBACN,YACA,CACF,CACF,CAEA,CAFE,EAEE,CAAA,EAAA,EAAA,gBAbuH,CAavH,AAAiB,EAAC,GAAO,CAE3B,IAAM,EAAiB,EAAiB,UAAU,CAAC,EAJA,GAIK,CAClD,EAAa,EAAK,SAAS,EAAE,CAAC,EAAe,CAEnD,CAFqD,EAEnC,MAAd,AAAoB,EACtB,OAGF,MAAO,CACL,KAAM,aACN,kBACA,CACF,CACF,CAGA,CAHE,GAGI,EAAY,EAAiB,IAd+F,KAWhH,CAG2B,CAAC,KAAK,CAC7C,EAAQ,EAAK,SAAS,EAAE,CAAC,EAAU,CAEzC,CAF2C,EAE9B,MAAT,AAAe,EAInB,MAAO,CACL,KAAM,QACN,aACA,CACF,CACF,EAkHqC,EAAQ,EAEzC,MAAK,EAAA,IAAI,CA/HgG,AA+H/F,mBAAmB,CAC3B,OAAO,AAhHb,SAAS,AAA0B,CAAM,CAAE,CAAgB,EAGzD,IAAM,EAAW,EAAiB,IAAI,CAAC,KAAK,CACtC,EAAO,EAAO,OAAO,CAAC,GAE5B,GAAY,KAF2B,CAEnC,AAAc,EAChB,MAAU,AAAJ,MACJ,CAAC,SAAS,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAAU,wBAJyE,eAIlC,CAAC,EAI1E,GAAI,CAAC,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,IAAS,CAAC,CAAA,EAAA,EAAA,eAAA,AAAe,EAAC,GAC1C,IADiD,EAC3C,AAAI,MACR,CAAC,SAAS,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAAU,wCAAwC,CAAC,EAK3E,IAAM,EAAY,EAAiB,SAAS,CAAC,KAAK,CAC5C,EAAQ,EAAK,SAAS,EAAE,CAAC,EAAU,CAEzC,CAF2C,EAE9B,MAAT,AAAe,EACjB,MAAM,AAAI,MACR,CAAC,SAAS,CAJ8D,CAI5D,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,GAAW,6BAA6B,EAAE,CAAA,EAAA,EAAA,OAAO,AAAP,EAC5D,GACA,eAAe,CAAC,EAItB,IAAM,EAAoB,EAAiB,YAAY,CAAC,KAAK,CACvD,EAAgB,EAAM,IAAI,CAAC,IAAI,CACnC,AAAC,GAAQ,EAAI,IAAI,GAAK,GAGxB,GAAqB,MAAjB,AAAuB,EAI3B,MANG,AAMI,CACL,KAAM,qBACN,QACA,gBACA,CACF,CACF,EAmEuC,EAAQ,EAE3C,MAAK,EAAA,IAAI,CAAC,IAjFmE,gBAiF/C,CA9DhC,IAAM,EAAgB,AA+DwB,EA/DP,IAAI,CAAC,KAAK,CAC3C,EAAY,AA8DoB,EA9Db,YAAY,CAAC,GAEtC,GAAK,CAAD,CAIJ,MAAO,CACL,CAPoD,CAEtC,GAKR,sBACN,CACF,QAuDE,MAAK,EAAA,IAAI,CAAC,6BAA6B,CAhE2F,AAiEhI,OAlDN,AAkDa,SAlDJ,AAAmC,CAAM,CAAE,CAAgB,EAGlE,IAAM,EAAgB,EAAiB,IAAI,CAAC,KAAK,CAC3C,EAAY,EAAO,YAAY,CAAC,GAEtC,GAAI,CAAC,EACH,MAAM,AAAI,CAH0C,EAEtC,GAEZ,CAAC,SAAS,EAAE,CAAA,EAAA,EAAA,OAAA,AAAO,EACjB,GACA,EANoF,0CAMxC,CAAC,EAInD,GAAM,CACJ,aAAc,CAAE,MAAO,CAAqB,CAAE,CAC/C,CAAG,EACE,EAAoB,EAAU,IAAI,CAAC,IAAI,CAC3C,AAAC,GAAQ,EAAI,IAAI,GAAK,GAGxB,GAAK,CAAD,CAIJ,MAAO,CACL,KAAM,IAPL,CAEqB,eAMtB,8BACA,CACF,CACF,EAoBgD,EAAQ,EACtD,CACF,6BAjCyF","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}