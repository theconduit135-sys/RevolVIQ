{"version":3,"sources":["../../../../../../../.gemini/antigravity/playground/final-cassini/node_modules/%40apollo/server/src/plugin/cacheControl/index.ts"],"sourcesContent":["import type { ApolloServerPlugin } from '../../externalTypes/index.js';\nimport {\n  type DirectiveNode,\n  getNamedType,\n  type GraphQLCompositeType,\n  type GraphQLField,\n  isCompositeType,\n  isInterfaceType,\n  isObjectType,\n  responsePathAsArray,\n} from 'graphql';\nimport { newCachePolicy } from '../../cachePolicy.js';\nimport { internalPlugin } from '../../internalPlugin.js';\nimport { LRUCache } from 'lru-cache';\nimport type {\n  CacheHint,\n  CacheScope,\n  GraphQLResolveInfoWithCacheControl,\n} from '@apollo/cache-control-types';\n\n/**\n * CacheAnnotation represents the contents of a `@cacheControl` directive.\n * (`inheritMaxAge` is part of this interface and not CacheHint, because\n * `inheritMaxAge` isn't a contributing piece of a cache policy: it just means\n * to not apply default values in some contexts.)\n */\ninterface CacheAnnotation extends CacheHint {\n  inheritMaxAge?: true;\n}\n\nexport interface ApolloServerPluginCacheControlOptions {\n  /**\n   * All root fields and fields returning objects or interfaces have this value\n   * for `maxAge` unless they set a cache hint with a non-undefined `maxAge`\n   * using `@cacheControl` or `setCacheHint`. The default is 0, which means \"not\n   * cacheable\". (That is: if you don't set `defaultMaxAge`, then every root\n   * field in your operation and every field with sub-fields must have a cache\n   * hint or the overall operation will not be cacheable.)\n   */\n  defaultMaxAge?: number;\n  /**\n   * Determines whether to set the `Cache-Control` HTTP header. If true (the\n   * default), the header is written on all responses (with a value of\n   * `no-store` for non-cacheable responses). If `'if-cacheable'`, the header is\n   * only written for cacheable responses. If false, the header is never\n   * written. A response is cacheable if its overall cache policy has a non-zero\n   * `maxAge`, and the body is a single result rather than an incremental\n   * delivery response, and the body contains no errors.\n   */\n  calculateHttpHeaders?: boolean | 'if-cacheable';\n  // For testing only.\n  __testing__cacheHints?: Map<string, CacheHint>;\n}\n\nexport function ApolloServerPluginCacheControl(\n  options: ApolloServerPluginCacheControlOptions = Object.create(null),\n): ApolloServerPlugin {\n  let typeAnnotationCache: LRUCache<GraphQLCompositeType, CacheAnnotation>;\n\n  let fieldAnnotationCache: LRUCache<\n    GraphQLField<unknown, unknown>,\n    CacheAnnotation\n  >;\n\n  return internalPlugin({\n    __internal_plugin_id__: 'CacheControl',\n    __is_disabled_plugin__: false,\n\n    async serverWillStart({ schema }) {\n      // Set the size of the caches to be equal to the number of composite types\n      // and fields in the schema respectively. This generally means that the\n      // cache will always have room for all the cache hints in the active\n      // schema but we won't have a memory leak as schemas are replaced in a\n      // gateway. (Once we're comfortable breaking compatibility with\n      // versions of Gateway older than 0.35.0, we should also run this code\n      // from a schemaDidLoadOrUpdate instead of serverWillStart. Using\n      // schemaDidLoadOrUpdate throws when combined with old gateways.)\n      typeAnnotationCache = new LRUCache<GraphQLCompositeType, CacheAnnotation>(\n        {\n          max: Object.values(schema.getTypeMap()).filter(isCompositeType)\n            .length,\n        },\n      );\n\n      fieldAnnotationCache = new LRUCache<\n        GraphQLField<unknown, unknown>,\n        CacheAnnotation\n      >({\n        max:\n          Object.values(schema.getTypeMap())\n            .filter(isObjectType)\n            .flatMap((t) => Object.values(t.getFields())).length +\n          Object.values(schema.getTypeMap())\n            .filter(isInterfaceType)\n            .flatMap((t) => Object.values(t.getFields())).length,\n      });\n\n      return undefined;\n    },\n\n    async requestDidStart(requestContext) {\n      function memoizedCacheAnnotationFromType(\n        t: GraphQLCompositeType,\n      ): CacheAnnotation {\n        const existing = typeAnnotationCache.get(t);\n        if (existing) {\n          return existing;\n        }\n        const annotation = cacheAnnotationFromType(t);\n        typeAnnotationCache.set(t, annotation);\n        return annotation;\n      }\n\n      function memoizedCacheAnnotationFromField(\n        field: GraphQLField<unknown, unknown>,\n      ): CacheAnnotation {\n        const existing = fieldAnnotationCache.get(field);\n        if (existing) {\n          return existing;\n        }\n        const annotation = cacheAnnotationFromField(field);\n        fieldAnnotationCache.set(field, annotation);\n        return annotation;\n      }\n\n      const defaultMaxAge: number = options.defaultMaxAge ?? 0;\n      const calculateHttpHeaders = options.calculateHttpHeaders ?? true;\n      const { __testing__cacheHints } = options;\n\n      return {\n        async executionDidStart() {\n          // Did something set the overall cache policy before we've even\n          // started? If so, consider that as an override and don't touch it.\n          // Just put set up fake `info.cacheControl` objects and otherwise\n          // don't track cache policy.\n          //\n          // (This doesn't happen in practice using the core plugins: the main\n          // use case for restricting overallCachePolicy outside of this plugin\n          // is apollo-server-plugin-response-cache, but when it sets the policy\n          // we never get to execution at all.)\n          if (isRestricted(requestContext.overallCachePolicy)) {\n            // This is \"fake\" in the sense that it never actually affects\n            // requestContext.overallCachePolicy.\n            const fakeFieldPolicy = newCachePolicy();\n            return {\n              willResolveField({ info }) {\n                // This `as` is \"safe\" in the sense that this is the statement\n                // that makes a GraphQLResolveInfo into a\n                // GraphQLResolveInfoWithCacheControl.\n                (info as GraphQLResolveInfoWithCacheControl).cacheControl = {\n                  setCacheHint: (dynamicHint: CacheHint) => {\n                    fakeFieldPolicy.replace(dynamicHint);\n                  },\n                  cacheHint: fakeFieldPolicy,\n                  cacheHintFromType: memoizedCacheAnnotationFromType,\n                };\n              },\n            };\n          }\n\n          return {\n            willResolveField({ info }) {\n              const fieldPolicy = newCachePolicy();\n\n              let inheritMaxAge = false;\n\n              // If this field's resolver returns an object/interface/union\n              // (maybe wrapped in list/non-null), look for hints on that return\n              // type.\n              const targetType = getNamedType(info.returnType);\n              if (isCompositeType(targetType)) {\n                const typeAnnotation =\n                  memoizedCacheAnnotationFromType(targetType);\n                fieldPolicy.replace(typeAnnotation);\n                inheritMaxAge = !!typeAnnotation.inheritMaxAge;\n              }\n\n              // Look for hints on the field itself (on its parent type), taking\n              // precedence over previously calculated hints.\n              const fieldAnnotation = memoizedCacheAnnotationFromField(\n                info.parentType.getFields()[info.fieldName],\n              );\n\n              // Note that specifying `@cacheControl(inheritMaxAge: true)` on a\n              // field whose return type defines a `maxAge` gives precedence to\n              // the type's `maxAge`. (Perhaps this should be some sort of\n              // error.)\n              if (\n                fieldAnnotation.inheritMaxAge &&\n                fieldPolicy.maxAge === undefined\n              ) {\n                inheritMaxAge = true;\n                // Handle `@cacheControl(inheritMaxAge: true, scope: PRIVATE)`.\n                // (We ignore any specified `maxAge`; perhaps it should be some\n                // sort of error.)\n                if (fieldAnnotation.scope) {\n                  fieldPolicy.replace({ scope: fieldAnnotation.scope });\n                }\n              } else {\n                fieldPolicy.replace(fieldAnnotation);\n              }\n\n              // This `as` is \"safe\" in the sense that this is the statement\n              // that makes a GraphQLResolveInfo into a\n              // GraphQLResolveInfoWithCacheControl.\n              (info as GraphQLResolveInfoWithCacheControl).cacheControl = {\n                setCacheHint: (dynamicHint: CacheHint) => {\n                  fieldPolicy.replace(dynamicHint);\n                },\n                cacheHint: fieldPolicy,\n                cacheHintFromType: memoizedCacheAnnotationFromType,\n              };\n\n              // When the resolver is done, call restrict once. By calling\n              // restrict after the resolver instead of before, we don't need to\n              // \"undo\" the effect on overallCachePolicy of a static hint that\n              // gets refined by a dynamic hint.\n              return () => {\n                // If this field returns a composite type or is a root field and\n                // we haven't seen an explicit maxAge hint, set the maxAge to 0\n                // (uncached) or the default if specified in the constructor.\n                // (Non-object fields by default are assumed to inherit their\n                // cacheability from their parents. But on the other hand, while\n                // root non-object fields can get explicit hints from their\n                // definition on the Query/Mutation object, if that doesn't\n                // exist then there's no parent field that would assign the\n                // default maxAge, so we do it here.)\n                //\n                // You can disable this on a non-root field by writing\n                // `@cacheControl(inheritMaxAge: true)` on it. If you do this,\n                // then its children will be treated like root paths, since\n                // there is no parent maxAge to inherit.\n                //\n                // We do this in the end hook so that dynamic cache control\n                // prevents it from happening (eg,\n                // `info.cacheControl.cacheHint.restrict({maxAge: 60})` should\n                // work rather than doing nothing because we've already set the\n                // max age to the default of 0). This also lets resolvers assume\n                // any hint in `info.cacheControl.cacheHint` was explicitly set.\n                if (\n                  fieldPolicy.maxAge === undefined &&\n                  ((isCompositeType(targetType) && !inheritMaxAge) ||\n                    !info.path.prev)\n                ) {\n                  fieldPolicy.restrict({ maxAge: defaultMaxAge });\n                }\n\n                if (__testing__cacheHints && isRestricted(fieldPolicy)) {\n                  const path = responsePathAsArray(info.path).join('.');\n                  if (__testing__cacheHints.has(path)) {\n                    throw Error(\n                      \"shouldn't happen: addHint should only be called once per path\",\n                    );\n                  }\n                  __testing__cacheHints.set(path, {\n                    maxAge: fieldPolicy.maxAge,\n                    scope: fieldPolicy.scope,\n                  });\n                }\n                requestContext.overallCachePolicy.restrict(fieldPolicy);\n              };\n            },\n          };\n        },\n\n        async willSendResponse(requestContext) {\n          // This hook is just for setting response headers, so make sure that\n          // hasn't been disabled.\n          if (!calculateHttpHeaders) {\n            return;\n          }\n\n          const { response, overallCachePolicy } = requestContext;\n\n          // Look to see if something has already set the cache-control header.\n          // This could be a different plugin... or it could be this very plugin\n          // operating on a different operation in the same batched HTTP\n          // request.\n          const existingCacheControlHeader = parseExistingCacheControlHeader(\n            response.http.headers.get('cache-control'),\n          );\n\n          // If the header contains something other than a value that this\n          // plugin sets, then we leave it alone. We don't want to mangle\n          // something important that you set! That said, it's probably best to\n          // have only one piece of code that writes to a given header, so you\n          // should probably set `calculateHttpHeaders: false` on this plugin.\n          if (existingCacheControlHeader.kind === 'unparsable') {\n            return;\n          }\n\n          const cachePolicy = newCachePolicy();\n          cachePolicy.replace(overallCachePolicy);\n          if (existingCacheControlHeader.kind === 'parsable-and-cacheable') {\n            cachePolicy.restrict(existingCacheControlHeader.hint);\n          }\n          const policyIfCacheable = cachePolicy.policyIfCacheable();\n\n          if (\n            // This code path is only for if we believe it is cacheable.\n            policyIfCacheable &&\n            // Either there wasn't a cache-control header already, or we've\n            // already incorporated it into policyIfCacheable. (If we couldn't\n            // parse it, that means some other plugin or mechanism set the\n            // header. This is confusing, so we just don't make any more\n            // changes. You should probably set `calculateHttpHeaders` to false\n            // in that case and only set the header from one place.)\n            existingCacheControlHeader.kind !== 'uncacheable' &&\n            // At least for now, we don't set cache-control headers for\n            // incremental delivery responses, since we don't know if a later\n            // part of the execution will affect the cache policy (perhaps\n            // dynamically). (Note that willSendResponse is called when the\n            // initial payload is sent, not the final payload.)\n            response.body.kind === 'single' &&\n            !response.body.singleResult.errors\n          ) {\n            response.http.headers.set(\n              'cache-control',\n              `max-age=${\n                policyIfCacheable.maxAge\n              }, ${policyIfCacheable.scope.toLowerCase()}`,\n            );\n          } else if (calculateHttpHeaders !== 'if-cacheable') {\n            // The response is not cacheable, so make sure it doesn't get\n            // cached. This is especially important for GET requests, because\n            // browsers and other agents cache many GET requests by default.\n            // (But if some other plugin set the header to a value that this\n            // plugin does not produce, we don't do anything.)\n            response.http.headers.set(\n              'cache-control',\n              CACHE_CONTROL_HEADER_UNCACHEABLE,\n            );\n          }\n        },\n      };\n    },\n  });\n}\n\nconst CACHE_CONTROL_HEADER_CACHEABLE_REGEXP =\n  /^max-age=(\\d+), (public|private)$/;\nconst CACHE_CONTROL_HEADER_UNCACHEABLE = 'no-store';\n\ntype ExistingCacheControlHeader =\n  | { kind: 'no-header' }\n  | { kind: 'uncacheable' }\n  | { kind: 'parsable-and-cacheable'; hint: CacheHint }\n  | { kind: 'unparsable' };\n\nfunction parseExistingCacheControlHeader(\n  header: string | undefined,\n): ExistingCacheControlHeader {\n  if (!header) {\n    return { kind: 'no-header' };\n  }\n  if (header === CACHE_CONTROL_HEADER_UNCACHEABLE) {\n    return { kind: 'uncacheable' };\n  }\n  const match = CACHE_CONTROL_HEADER_CACHEABLE_REGEXP.exec(header);\n  if (!match) {\n    return { kind: 'unparsable' };\n  }\n  return {\n    kind: 'parsable-and-cacheable',\n    hint: {\n      maxAge: +match[1],\n      scope: match[2] === 'public' ? 'PUBLIC' : 'PRIVATE',\n    },\n  };\n}\n\nfunction cacheAnnotationFromDirectives(\n  directives: ReadonlyArray<DirectiveNode> | undefined,\n): CacheAnnotation | undefined {\n  if (!directives) return undefined;\n\n  const cacheControlDirective = directives.find(\n    (directive) => directive.name.value === 'cacheControl',\n  );\n  if (!cacheControlDirective) return undefined;\n\n  if (!cacheControlDirective.arguments) return undefined;\n\n  const maxAgeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'maxAge',\n  );\n  const scopeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'scope',\n  );\n  const inheritMaxAgeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'inheritMaxAge',\n  );\n\n  const scopeString =\n    scopeArgument?.value?.kind === 'EnumValue'\n      ? scopeArgument.value.value\n      : undefined;\n\n  const scope: CacheScope | undefined =\n    scopeString === 'PUBLIC' || scopeString === 'PRIVATE'\n      ? scopeString\n      : undefined;\n\n  if (\n    inheritMaxAgeArgument?.value?.kind === 'BooleanValue' &&\n    inheritMaxAgeArgument.value.value\n  ) {\n    // We ignore maxAge if it is also specified.\n    return { inheritMaxAge: true, scope };\n  }\n\n  return {\n    maxAge:\n      maxAgeArgument?.value?.kind === 'IntValue'\n        ? parseInt(maxAgeArgument.value.value)\n        : undefined,\n    scope,\n  };\n}\n\nfunction cacheAnnotationFromType(t: GraphQLCompositeType): CacheAnnotation {\n  if (t.astNode) {\n    const hint = cacheAnnotationFromDirectives(t.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  if (t.extensionASTNodes) {\n    for (const node of t.extensionASTNodes) {\n      const hint = cacheAnnotationFromDirectives(node.directives);\n      if (hint) {\n        return hint;\n      }\n    }\n  }\n  return {};\n}\n\nfunction cacheAnnotationFromField(\n  field: GraphQLField<unknown, unknown>,\n): CacheAnnotation {\n  if (field.astNode) {\n    const hint = cacheAnnotationFromDirectives(field.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  return {};\n}\n\nfunction isRestricted(hint: CacheHint) {\n  return hint.maxAge !== undefined || hint.scope !== undefined;\n}\n"],"names":[],"mappings":"wDACA,EAME,CANK,CAOL,CAAA,AALA,CAKY,EACZ,IAFe,CAIjB,CAHE,CAG6B,CAAxB,CAA+C,AARxC,CAQL,AAA6C,CAAA,AALpD,IAKmD,CAAC,EACtD,CAHqB,CAGU,CAAxB,CAFN,AAEwD,CAAhD,AAAgD,CADlC,AACkC,EANxC,AAKQ,EAJvB,AAGK,GAGP,AADwD,CAAC,AAD1B,CAEM,CAA9B,CAA8B,CAA5B,AAA4B,CAHrB,AAGqB,AADd,CAFN,CAEQ,KA0CnB,AAzCW,CADc,CACZ,MAAM,CAyCT,EACd,EAAiD,MA1Cf,AA0CqB,CAAC,AA1CrB,MA0C2B,CAAC,IAAI,CAAC,EAEpE,IAAI,CAHwC,CAKxC,EAKJ,MAAA,CAAA,EAAO,EAAA,IAPiE,CAAC,EAKxE,CAAC,MAEK,AAAc,EAAC,CACpB,sBAAsB,CAAE,cAAc,CACtC,sBAAsB,EAAE,EAExB,GAF6B,EAExB,CAAC,eAAe,CAAC,QAAE,CAAM,CAAE,EAS9B,EAAsB,IAAI,EAAA,QAAQ,CAChC,CACE,CAFe,EAEZ,CAAE,MAAM,CAAC,MAAM,CAAC,EAAO,IAAD,MAAW,EAAE,CAAC,CAAC,MAAM,CAAC,EAAA,eAAe,CAAC,CAC5D,MAAM,CACV,CACF,CAAC,AAEF,EAAuB,IAAI,EAAA,QAAQ,CAGjC,CACA,EAJkB,CAIf,CACD,MAAM,CAAC,MAAM,CAAC,EAAO,IAAD,MAAW,EAAE,CAAC,CAC/B,MAAM,CAAC,EAAA,YAAY,CAAC,CACpB,OAAO,CAAC,AAAC,CAAC,EAAE,AAAG,CAAD,KAAO,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,MAAM,CACtD,MAAM,CAAC,MAAM,CAAC,EAAO,IAAD,MAAW,EAAE,CAAC,CAC/B,MAAM,CAAC,EAAA,eAAe,CAAC,CACvB,OAAO,CAAC,AAAC,CAAC,EAAK,AAAH,CAAE,KAAO,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,MAAM,CACzD,CAAC,AAGJ,CAHK,AAGJ,CAED,KAAK,CAAC,eAAe,CAAC,CAAc,EAClC,SAAS,EACP,CAAuB,EAEvB,IAAM,EAAW,EAAoB,GAAG,CAA1B,AAA2B,CAAC,CAAC,CAAC,AAC5C,GAAI,EACF,KAFkC,CAHE,AAI1B,CACH,CADK,CAGd,AAHe,IAGT,EAFW,AAEE,AAwT3B,CA1T0B,OAEF,CAwTf,AAAwB,CAAuB,EACtD,GAAI,CAAC,CAAC,MAzT0C,CAyTnC,CAAE,CAAC,AACd,IAAM,EAAO,AAFe,EAElB,AAAiC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,AACjE,GAAI,EADsC,AAExC,EADM,EAAE,CAAC,EACF,CAEX,CAAC,AACD,EAHe,CAAC,AAGZ,CAAC,CAAC,iBAAiB,CACrB,CADuB,CAAC,EACnB,IAAM,IAAI,CAAI,CAAC,CAAC,iBAAiB,CAAE,CAAC,AACvC,IAAM,EAAO,EAAH,AAAiC,EAAK,EAAD,QAAW,CAAC,CAAC,AAC5D,GAAI,EACF,EADM,EAAE,CAAC,EACF,CAFiC,AAI5C,CAEF,AAFG,EAFc,CAAC,GAIX,CAAA,CACT,AADW,CACV,AADW,CAvUuC,CAAC,CAAC,CAAC,AAE9C,OADA,EAAoB,GAAG,CAAC,CAAC,CAAE,GACpB,CACT,CAcA,AAdC,IAcK,CAhBiC,CAAlB,AAAmB,AAgBV,CAhBW,CACtB,AAemB,CAflB,IAeiB,IAAlB,IAAgC,EAAI,CAAC,CAAC,AACnD,EAAuB,EAAQ,KAAD,WAAV,IAA+B,GAAI,EACvD,EAD2D,CAAC,oBAC1D,CAAqB,CAAE,CAAG,EAElC,KAFyC,CAAC,AAEnC,CACL,KAAK,CAAC,iBAAiB,GAUrB,GAAI,EAAa,EAAe,QAAhB,IAAe,MAAmB,CAAC,CAAE,CAGnD,AAHoD,IAG9C,EAAe,CAAA,EAAG,EAAA,QAAH,MAAG,AAAc,EAAE,CAAC,CACzC,MAAO,CACL,gBAAgB,CAAC,MAAE,CAAI,CAAE,EAItB,EAA4C,EAAD,UAAa,CAAG,CAC1D,YAAY,CAAE,AAAC,IACb,EAAgB,KADmB,EAAE,AACd,CAAC,CADe,CAEzC,CAAC,CACD,CAFiB,MAAoB,CAAC,CAAC,AAE9B,CAAE,EACX,aAD0B,IACT,CAAE,EACpB,AACH,CADI,AACH,CAEL,AADG,CAGH,AAHI,AACH,MAEM,CACL,gBAAgB,CAAC,EAPuC,IAOrC,CAAI,CAAE,EACvB,IAAM,EAAW,CAAA,EAAG,EAAA,IAAH,UAAG,AAAc,EAAE,CAAC,CAEjC,GAAgB,EAKd,EAAU,CALS,AAKT,CALU,CAKP,EAAA,CALF,EAKD,SAAG,AAAY,EAAC,EAAK,EAAD,QAAW,CAAC,CAAC,AACjD,GAAA,CAAA,EAAI,EAAA,eAAA,AAAe,EAAC,GAAa,CAAC,AAChC,IAAM,EADsB,AAE1B,CAF2B,CAEK,GAClC,EAAY,KADgC,AADxB,CACyB,CAAC,AAC3B,CAAC,CAAT,EACX,EAAgB,CAAC,CAAC,EAAe,KADC,CAAC,CACtB,AADuB,AADH,KAED,CAAc,AAChD,CAIA,AALiD,AAChD,IAIK,EAAkB,AAlEhC,SAAS,AACP,CAAqC,EAErC,CA+D2B,GA/DrB,EAAW,EAAqB,GAAG,CAAC,AAA5B,GACd,EAD+C,CAC3C,AAD4C,CAAC,CAE/C,AA6D4D,MA/DzB,AACzB,CACH,CADK,CAJyB,AAIxB,AAGf,IAAM,EAFW,AAEE,AA8T3B,CAhU0B,OAEF,CA+TtB,AADO,CAC8B,EAErC,GAAI,EAAM,GAAD,IAjUwC,AAiUhC,CAAE,CAAC,AAClB,IAAM,EAAO,CAJgB,CAInB,AAAiC,EAAM,GAAD,IAAQ,CAAC,UAAU,CAAC,CAAC,AACrE,GAAI,EADsC,AAExC,EADM,EAAE,CAAC,EACF,CAEX,CAAC,AACD,EAHe,CAAC,GAGT,CAAA,CAAE,AACX,CAAC,AADW,CAvUwC,GAE5C,EAFiD,CAAC,CAAC,GACnD,EAAqB,GAAG,CAAC,EAAO,GAAF,AACvB,CACT,CAAC,CAyDS,EAAK,EA3D6B,AA2D9B,CA3D+B,CAAC,AAAxB,CACH,CAAC,IA0DK,CAAC,SAAS,EAAE,CAAC,EAAK,EAAD,OAAU,CAAC,CAC5C,CAoCD,AApCE,OAOA,EAAgB,aAAD,AAAc,OACN,IAAvB,EAAY,GAAoB,EAChC,CAAC,AADiB,EAElB,CAFW,EAEK,EAIZ,EAJgB,AAIA,CAJC,IAII,CAJZ,CAIc,AACzB,CAD0B,CACd,IADK,GACE,CAAC,CAAT,AAAW,KAAK,CAAE,EAAgB,KAAK,CAAE,CAAC,CAAC,CAGxD,EAAY,EAHkC,KAG3B,CAAC,CAAT,EAMZ,EAA4C,EAAD,QANP,CAAC,CAAC,AAMkB,CAAG,CAC1D,YAAY,CAAE,AAAC,IACb,EAAY,KADuB,EAAE,AAClB,CAAC,CAAT,AAD4B,CAEzC,CAAC,CACD,OAFiC,CAAC,CAAC,AAE1B,CAAE,EACX,SADsB,QACL,CAAE,EACpB,CAAC,AAMK,GAAG,EAAE,AA8BV,QAPyB,IAAvB,EAAY,GAAoB,GAAd,CAClB,EA/BgD,AA+B/C,AADU,CACV,EAAC,EAAA,eAAA,AAAe,EAAC,IAAe,CAAC,GAChC,CAAC,CADyB,CACpB,AADqB,EACtB,EAAK,CAAC,EADkC,CAAC,CACnC,AAAI,CAAC,EAClB,AACA,CADC,CACW,QAAQ,CAAT,AAAU,CAAE,MAAM,CAAE,CAAa,CAAE,CAAC,CAAC,AAG9C,GAAyB,EAAa,GAAc,CAHV,AAGW,AACvD,IAAM,EADiC,AAC7B,CADyC,AACzC,CAD0C,AAC1C,CAAG,EAAA,CADU,kBACV,AAAmB,EAAC,EAAK,EAAD,EAAK,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,AACtD,GAAI,EAAsB,GAAG,CAAC,GAC5B,CADgC,CAAC,EAAE,CAAC,CAC9B,KAAK,CADY,AAErB,+DAA+D,CAChE,CAAC,AAEJ,EAAsB,GAAG,CAAC,EAAM,CAC9B,CAD4B,KACtB,CAAE,EAAY,GADD,GACO,CAC1B,EADmB,GACd,CAAE,EAAY,KAAK,CACzB,CAAC,AACJ,CADK,AACJ,AACD,CAHsB,CAGP,YAAD,MAAmB,CAAC,QAAQ,CAAC,EAC7C,CAAC,AACH,CADI,AACH,CACF,AACH,CADI,AACH,CAED,IAN8D,CAMzD,AAN0D,CAMzD,AAN0D,gBAM1C,CAAC,CAAc,EAGnC,GAAI,CAAC,EACH,OAAO,AAGT,GAAM,QAJmB,EAAE,AAInB,CAJoB,AAIZ,oBAAE,CAAkB,CAAE,CAAG,EAMnC,EAA6B,AAuE7C,SAAS,AACP,CA9E+D,AA8ErC,CA9EsC,CAgFhE,GAAI,CAAC,EACH,IADS,EA1E6B,AA0E3B,AACJ,CADK,AACH,IAAI,CAAE,CA3EyD,SAuEpC,CAIV,CAAE,CAAC,AAE/B,GAAI,IAAW,EAAL,AACR,MAAO,CAAE,IAAI,CAAE,aAAa,CAAE,CAAC,AAEjC,GAH+C,CAGzC,CAH2C,CAGnC,AAHoC,EAGE,CAAzC,GAA6C,CAAC,MAAM,CAAC,CAAC,EACjE,AAAK,EAGE,CACL,CAJE,CAAM,EAIJ,AAJM,CAIJ,AAJK,YADsC,YAKnB,CAC9B,IAAI,CAAE,CACJ,MAAM,CAAE,CAAC,CAAK,CAAC,CAAC,CAAC,CACjB,KAAK,CAAE,AAAa,QAAQ,CAAC,CAAC,EAAlB,CAAC,CAAC,CAAC,CAAgB,QAAQ,CAAC,AAAE,CAAD,QAAU,CACpD,CACF,CAAC,AARO,CAAE,IAAI,CAAE,YAAY,CAS/B,AATiC,CAShC,AATiC,CAjFtB,EAAS,IAAI,CAAC,CAAN,MAAa,CAAC,GAAG,CAAC,eAAe,CAAC,CAC3C,CAAC,AAOF,GAAwC,YAAY,EAAE,CAAlD,AAAmD,EAAxB,IAAI,CACjC,OAAO,AAGT,IAAM,EAAW,CAAA,EAAG,EAAA,CAJU,GAIb,UAAG,AAAc,EAAE,CAAC,CACrC,EAAY,OAAO,CAAC,CAAT,EAC6B,eADF,CAAC,CAAC,OACwB,EAAE,CAA9D,AAA+D,EAApC,IAAI,EACjC,EAAY,QAAQ,CAAT,AAAU,EAA2B,IAAI,CAAC,AADzB,CAC0B,AAExD,IAAM,EAAoB,EAAY,SAAD,CAFY,GAE1B,IAAgC,EAAE,CAAC,AAIxD,GAOoC,aAAa,CAPhC,EAOjB,EAA2B,IAAI,EAMR,QAAQ,GAA/B,EAAS,IAAI,CANa,AAMZ,CAAN,GAAU,EAClB,CAAC,EAAS,IAAI,CAAC,CAAN,WAAkB,CAAC,MAAM,CAElC,CADA,CACS,AADR,IACY,CAAC,CAAN,MAAa,CAAC,GAAG,CACvB,eAAe,CACf,CAAA,QAAA,EACE,EAAkB,MACpB,CAAA,EAAA,EAAK,EAAkB,EADJ,GACS,CAAC,SAAP,EAAkB,EAAE,CAAA,CAAE,CAC7C,CAAC,AACgC,cAAc,EAAE,CAAzC,AAA0C,GAMnD,EAAS,IAAI,CAAC,CAAN,MAAa,CAAC,EANO,CAMJ,CACvB,eAAe,CACf,EAGN,CAAC,CACF,AACH,CADI,AACH,CACF,CAAC,AACJ,CADK,AACJ,AAED,IAAM,EACJ,kBAV4C,CACjC,CAAC,eAQ6B,AACN,CAAC,AAChC,EAAmC,UAAU,CA8BnD,AA9BoD,SA8B3C,EACP,CAAoD,EAEpD,GAAI,CAAC,CAjC+B,CAiCnB,OAAO,AAExB,CAFe,GAET,EAAwB,EAAW,CAFR,CAAC,CAHE,CAKS,CAC3C,AAAC,GADqC,AACE,MAA9B,EAAE,CADa,KAC6B,CACvD,CAAC,CADe,CAAD,CAAW,IAAI,CAAC,EAAN,GAAW,EAErC,GAAI,CAAC,GAED,CAAC,EAAsB,SAAS,CAFR,CAEU,IAFZ,EAAS,AAInC,CAF6C,CAAnB,EAEpB,EAAiB,EAAsB,CAJD,CAAC,AAES,CAAC,MAED,CAAlC,AAAmC,IAAI,CACzD,AAAC,GAAqC,CADI,IACjC,EAAE,CAAmC,CAC/C,CAAC,CADc,CAAD,CAAU,IAAI,CAAC,CAAN,IAAW,EAE7B,EAAgB,EAAsB,SAAzB,AAAkC,CAAC,IAAI,CACxD,AAAC,GAAqC,CADG,IAChC,EAAoC,AAAlC,CACZ,CAAC,CADc,CAAD,CAAU,IAAI,CAAC,CAAN,IAAW,EAE7B,EAAwB,EAAsB,SAAS,CAAC,IAAI,CAC/D,AAAD,EADyB,CACa,CADW,IACxC,EAAE,QAA0C,CACtD,CAAC,CADc,CAAD,CAAU,IAAI,CAAC,CAAN,IAAW,EAG7B,EACJ,GAAe,KAAK,CADL,CACO,GAAT,CAAa,GAAK,WAAW,CACtC,EAAc,KAAK,CAAC,KAAP,AAAY,MACzB,EAEA,EACY,GADP,EAFI,CAAC,EAGU,GAAxB,GAA4C,QAAjC,CAA0C,GAAzB,EACxB,OACA,EAFmC,EACxB,KACF,AAEf,AACE,CAHc,EAGS,KAAK,EAAE,IAAI,GAAK,IAAlB,UAAgC,EACrD,EAAsB,KAAK,CAAC,KAAK,CAG1B,CAFP,AAES,CAFR,KADoB,OAGC,EAAE,IAAI,IAAE,CAAK,CAAE,CAAC,AAGjC,CACL,CAJmC,KAI7B,CACJ,GAAgB,KAAK,EAAE,IAAI,AAAb,GAAkB,UAAU,CACtC,QAAQ,CAAC,EAAe,KAAK,CAAC,KAAK,CAAZ,AAAa,MACpC,QACN,CADe,CAEhB,AACH,CAgCA,AAjCI,AACH,EAFQ,OAkCA,EAAa,CAAe,EACnC,OADmB,AACI,SAAhB,AAAyB,EAApB,EAAD,IAAO,OAAiC,IAAf,EAAK,EAAD,CAAoB,CAAC,CAAf,AAChD,CAAC"}