module.exports=[22009,t=>{"use strict";let e="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,i=new Set,s="object"==typeof process&&process?process:{},h=(t,e,i,h)=>{"function"==typeof s.emitWarning?s.emitWarning(t,e,i,h):console.error(`[${i}] ${e}: ${t}`)},r=globalThis.AbortController,o=globalThis.AbortSignal;if(void 0===r){o=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(t,e){this._onabort.push(e)}},r=class{constructor(){e()}signal=new o;abort(t){if(!this.signal.aborted){for(let e of(this.signal.reason=t,this.signal.aborted=!0,this.signal._onabort))e(t);this.signal.onabort?.(t)}}};let t=s.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1",e=()=>{t&&(t=!1,h("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}Symbol("type");let a=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),l=t=>a(t)?t<=256?Uint8Array:t<=65536?Uint16Array:t<=0x100000000?Uint32Array:t<=Number.MAX_SAFE_INTEGER?n:null:null;class n extends Array{constructor(t){super(t),this.fill(0)}}class d{heap;length;static #t=!1;static create(t){let e=l(t);if(!e)return[];d.#t=!0;let i=new d(t,e);return d.#t=!1,i}constructor(t,e){if(!d.#t)throw TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}class c{#e;#i;#s;#h;#r;#o;#a;#l;get perf(){return this.#l}ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#n;#d;#c;#u;#f;#p;#g;#v;#m;#y;#S;#z;#L;#T;#_;#x;#k;#F;#A;static unsafeExposeInternals(t){return{starts:t.#L,ttls:t.#T,autopurgeTimers:t.#_,sizes:t.#z,keyMap:t.#c,keyList:t.#u,valList:t.#f,next:t.#p,prev:t.#g,get head(){return t.#v},get tail(){return t.#m},free:t.#y,isBackgroundFetch:e=>t.#b(e),backgroundFetch:(e,i,s,h)=>t.#w(e,i,s,h),moveToTail:e=>t.#E(e),indexes:e=>t.#O(e),rindexes:e=>t.#M(e),isStale:e=>t.#D(e)}}get max(){return this.#e}get maxSize(){return this.#i}get calculatedSize(){return this.#d}get size(){return this.#n}get fetchMethod(){return this.#o}get memoMethod(){return this.#a}get dispose(){return this.#s}get onInsert(){return this.#h}get disposeAfter(){return this.#r}constructor(t){const{max:s=0,ttl:r,ttlResolution:o=1,ttlAutopurge:n,updateAgeOnGet:u,updateAgeOnHas:f,allowStale:p,dispose:g,onInsert:v,disposeAfter:m,noDisposeOnSet:y,noUpdateTTL:S,maxSize:z=0,maxEntrySize:L=0,sizeCalculation:T,fetchMethod:_,memoMethod:x,noDeleteOnFetchRejection:k,noDeleteOnStaleGet:F,allowStaleOnFetchRejection:A,allowStaleOnFetchAbort:b,ignoreFetchAbort:w,perf:E}=t;if(void 0!==E&&"function"!=typeof E?.now)throw TypeError("perf option must have a now() method if specified");if(this.#l=E??e,0!==s&&!a(s))throw TypeError("max option must be a nonnegative integer");const O=s?l(s):Array;if(!O)throw Error("invalid max value: "+s);if(this.#e=s,this.#i=z,this.maxEntrySize=L||this.#i,this.sizeCalculation=T,this.sizeCalculation){if(!this.#i&&!this.maxEntrySize)throw TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw TypeError("sizeCalculation set to non-function")}if(void 0!==x&&"function"!=typeof x)throw TypeError("memoMethod must be a function if defined");if(this.#a=x,void 0!==_&&"function"!=typeof _)throw TypeError("fetchMethod must be a function if specified");if(this.#o=_,this.#k=!!_,this.#c=new Map,this.#u=Array(s).fill(void 0),this.#f=Array(s).fill(void 0),this.#p=new O(s),this.#g=new O(s),this.#v=0,this.#m=0,this.#y=d.create(s),this.#n=0,this.#d=0,"function"==typeof g&&(this.#s=g),"function"==typeof v&&(this.#h=v),"function"==typeof m?(this.#r=m,this.#S=[]):(this.#r=void 0,this.#S=void 0),this.#x=!!this.#s,this.#A=!!this.#h,this.#F=!!this.#r,this.noDisposeOnSet=!!y,this.noUpdateTTL=!!S,this.noDeleteOnFetchRejection=!!k,this.allowStaleOnFetchRejection=!!A,this.allowStaleOnFetchAbort=!!b,this.ignoreFetchAbort=!!w,0!==this.maxEntrySize){if(0!==this.#i&&!a(this.#i))throw TypeError("maxSize must be a positive integer if specified");if(!a(this.maxEntrySize))throw TypeError("maxEntrySize must be a positive integer if specified");this.#I()}if(this.allowStale=!!p,this.noDeleteOnStaleGet=!!F,this.updateAgeOnGet=!!u,this.updateAgeOnHas=!!f,this.ttlResolution=a(o)||0===o?o:1,this.ttlAutopurge=!!n,this.ttl=r||0,this.ttl){if(!a(this.ttl))throw TypeError("ttl must be a positive integer if specified");this.#C()}if(0===this.#e&&0===this.ttl&&0===this.#i)throw TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#e&&!this.#i){const t="LRU_CACHE_UNBOUNDED";i.has(t)||(i.add(t),h("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",t,c))}}getRemainingTTL(t){return this.#c.has(t)?1/0:0}#C(){let t=new n(this.#e),e=new n(this.#e);this.#T=t,this.#L=e;let i=this.ttlAutopurge?Array(this.#e):void 0;this.#_=i,this.#W=(s,h,r=this.#l.now())=>{if(e[s]=0!==h?r:0,t[s]=h,i?.[s]&&(clearTimeout(i[s]),i[s]=void 0),0!==h&&i){let t=setTimeout(()=>{this.#D(s)&&this.#R(this.#u[s],"expire")},h+1);t.unref&&t.unref(),i[s]=t}},this.#B=i=>{e[i]=0!==t[i]?this.#l.now():0},this.#U=(i,r)=>{if(t[r]){let o=t[r],a=e[r];if(!o||!a)return;i.ttl=o,i.start=a,i.now=s||h();let l=i.now-a;i.remainingTTL=o-l}};let s=0,h=()=>{let t=this.#l.now();if(this.ttlResolution>0){s=t;let e=setTimeout(()=>s=0,this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=i=>{let r=this.#c.get(i);if(void 0===r)return 0;let o=t[r],a=e[r];return o&&a?o-((s||h())-a):1/0},this.#D=i=>{let r=e[i],o=t[i];return!!o&&!!r&&(s||h())-r>o}}#B=()=>{};#U=()=>{};#W=()=>{};#D=()=>!1;#I(){let t=new n(this.#e);this.#d=0,this.#z=t,this.#G=e=>{this.#d-=t[e],t[e]=0},this.#N=(t,e,i,s)=>{if(this.#b(e))return 0;if(!a(i))if(s){if("function"!=typeof s)throw TypeError("sizeCalculation must be a function");if(!a(i=s(e,t)))throw TypeError("sizeCalculation return invalid (expect positive integer)")}else throw TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return i},this.#j=(e,i,s)=>{if(t[e]=i,this.#i){let i=this.#i-t[e];for(;this.#d>i;)this.#H(!0)}this.#d+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#d)}}#G=t=>{};#j=(t,e,i)=>{};#N=(t,e,i,s)=>{if(i||s)throw TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#O({allowStale:t=this.allowStale}={}){if(this.#n)for(let e=this.#m;this.#P(e)&&((t||!this.#D(e))&&(yield e),e!==this.#v);)e=this.#g[e]}*#M({allowStale:t=this.allowStale}={}){if(this.#n)for(let e=this.#v;this.#P(e)&&((t||!this.#D(e))&&(yield e),e!==this.#m);)e=this.#p[e]}#P(t){return void 0!==t&&this.#c.get(this.#u[t])===t}*entries(){for(let t of this.#O())void 0===this.#f[t]||void 0===this.#u[t]||this.#b(this.#f[t])||(yield[this.#u[t],this.#f[t]])}*rentries(){for(let t of this.#M())void 0===this.#f[t]||void 0===this.#u[t]||this.#b(this.#f[t])||(yield[this.#u[t],this.#f[t]])}*keys(){for(let t of this.#O()){let e=this.#u[t];void 0===e||this.#b(this.#f[t])||(yield e)}}*rkeys(){for(let t of this.#M()){let e=this.#u[t];void 0===e||this.#b(this.#f[t])||(yield e)}}*values(){for(let t of this.#O())void 0===this.#f[t]||this.#b(this.#f[t])||(yield this.#f[t])}*rvalues(){for(let t of this.#M())void 0===this.#f[t]||this.#b(this.#f[t])||(yield this.#f[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(let i of this.#O()){let s=this.#f[i],h=this.#b(s)?s.__staleWhileFetching:s;if(void 0!==h&&t(h,this.#u[i],this))return this.get(this.#u[i],e)}}forEach(t,e=this){for(let i of this.#O()){let s=this.#f[i],h=this.#b(s)?s.__staleWhileFetching:s;void 0!==h&&t.call(e,h,this.#u[i],this)}}rforEach(t,e=this){for(let i of this.#M()){let s=this.#f[i],h=this.#b(s)?s.__staleWhileFetching:s;void 0!==h&&t.call(e,h,this.#u[i],this)}}purgeStale(){let t=!1;for(let e of this.#M({allowStale:!0}))this.#D(e)&&(this.#R(this.#u[e],"expire"),t=!0);return t}info(t){let e=this.#c.get(t);if(void 0===e)return;let i=this.#f[e],s=this.#b(i)?i.__staleWhileFetching:i;if(void 0===s)return;let h={value:s};if(this.#T&&this.#L){let t=this.#T[e],i=this.#L[e];t&&i&&(h.ttl=t-(this.#l.now()-i),h.start=Date.now())}return this.#z&&(h.size=this.#z[e]),h}dump(){let t=[];for(let e of this.#O({allowStale:!0})){let i=this.#u[e],s=this.#f[e],h=this.#b(s)?s.__staleWhileFetching:s;if(void 0===h||void 0===i)continue;let r={value:h};if(this.#T&&this.#L){r.ttl=this.#T[e];let t=this.#l.now()-this.#L[e];r.start=Math.floor(Date.now()-t)}this.#z&&(r.size=this.#z[e]),t.unshift([i,r])}return t}load(t){for(let[e,i]of(this.clear(),t)){if(i.start){let t=Date.now()-i.start;i.start=this.#l.now()-t}this.set(e,i.value,i)}}set(t,e,i={}){if(void 0===e)return this.delete(t),this;let{ttl:s=this.ttl,start:h,noDisposeOnSet:r=this.noDisposeOnSet,sizeCalculation:o=this.sizeCalculation,status:a}=i,{noUpdateTTL:l=this.noUpdateTTL}=i,n=this.#N(t,e,i.size||0,o);if(this.maxEntrySize&&n>this.maxEntrySize)return a&&(a.set="miss",a.maxEntrySizeExceeded=!0),this.#R(t,"set"),this;let d=0===this.#n?void 0:this.#c.get(t);if(void 0===d)d=0===this.#n?this.#m:0!==this.#y.length?this.#y.pop():this.#n===this.#e?this.#H(!1):this.#n,this.#u[d]=t,this.#f[d]=e,this.#c.set(t,d),this.#p[this.#m]=d,this.#g[d]=this.#m,this.#m=d,this.#n++,this.#j(d,n,a),a&&(a.set="add"),l=!1,this.#A&&this.#h?.(e,t,"add");else{this.#E(d);let i=this.#f[d];if(e!==i){if(this.#k&&this.#b(i)){i.__abortController.abort(Error("replaced"));let{__staleWhileFetching:e}=i;void 0!==e&&!r&&(this.#x&&this.#s?.(e,t,"set"),this.#F&&this.#S?.push([e,t,"set"]))}else!r&&(this.#x&&this.#s?.(i,t,"set"),this.#F&&this.#S?.push([i,t,"set"]));if(this.#G(d),this.#j(d,n,a),this.#f[d]=e,a){a.set="replace";let t=i&&this.#b(i)?i.__staleWhileFetching:i;void 0!==t&&(a.oldValue=t)}}else a&&(a.set="update");this.#A&&this.onInsert?.(e,t,e===i?"update":"replace")}if(0===s||this.#T||this.#C(),this.#T&&(l||this.#W(d,s,h),a&&this.#U(a,d)),!r&&this.#F&&this.#S){let t,e=this.#S;for(;t=e?.shift();)this.#r?.(...t)}return this}pop(){try{for(;this.#n;){let t=this.#f[this.#v];if(this.#H(!0),this.#b(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(this.#F&&this.#S){let t,e=this.#S;for(;t=e?.shift();)this.#r?.(...t)}}}#H(t){let e=this.#v,i=this.#u[e],s=this.#f[e];return this.#k&&this.#b(s)?s.__abortController.abort(Error("evicted")):(this.#x||this.#F)&&(this.#x&&this.#s?.(s,i,"evict"),this.#F&&this.#S?.push([s,i,"evict"])),this.#G(e),this.#_?.[e]&&(clearTimeout(this.#_[e]),this.#_[e]=void 0),t&&(this.#u[e]=void 0,this.#f[e]=void 0,this.#y.push(e)),1===this.#n?(this.#v=this.#m=0,this.#y.length=0):this.#v=this.#p[e],this.#c.delete(i),this.#n--,e}has(t,e={}){let{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,h=this.#c.get(t);if(void 0!==h){let t=this.#f[h];if(this.#b(t)&&void 0===t.__staleWhileFetching)return!1;if(!this.#D(h))return i&&this.#B(h),s&&(s.has="hit",this.#U(s,h)),!0;s&&(s.has="stale",this.#U(s,h))}else s&&(s.has="miss");return!1}peek(t,e={}){let{allowStale:i=this.allowStale}=e,s=this.#c.get(t);if(void 0===s||!i&&this.#D(s))return;let h=this.#f[s];return this.#b(h)?h.__staleWhileFetching:h}#w(t,e,i,s){let h=void 0===e?void 0:this.#f[e];if(this.#b(h))return h;let o=new r,{signal:a}=i;a?.addEventListener("abort",()=>o.abort(a.reason),{signal:o.signal});let l={signal:o.signal,options:i,context:s},n=(s,h=!1)=>{let{aborted:r}=o.signal,a=i.ignoreFetchAbort&&void 0!==s;if(i.status&&(r&&!h?(i.status.fetchAborted=!0,i.status.fetchError=o.signal.reason,a&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),r&&!a&&!h)return d(o.signal.reason);let n=this.#f[e];return(n===u||a&&h&&void 0===n)&&(void 0===s?void 0!==u.__staleWhileFetching?this.#f[e]=u.__staleWhileFetching:this.#R(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,s,l.options))),s},d=s=>{let{aborted:h}=o.signal,r=h&&i.allowStaleOnFetchAbort,a=r||i.allowStaleOnFetchRejection,l=a||i.noDeleteOnFetchRejection;if(this.#f[e]===u&&(l&&void 0!==u.__staleWhileFetching?r||(this.#f[e]=u.__staleWhileFetching):this.#R(t,"fetch")),a)return i.status&&void 0!==u.__staleWhileFetching&&(i.status.returnedStale=!0),u.__staleWhileFetching;if(u.__returned===u)throw s},c=(e,s)=>{let r=this.#o?.(t,h,l);r&&r instanceof Promise&&r.then(t=>e(void 0===t?void 0:t),s),o.signal.addEventListener("abort",()=>{(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort)&&(e(void 0),i.allowStaleOnFetchAbort&&(e=t=>n(t,!0)))})};i.status&&(i.status.fetchDispatched=!0);let u=new Promise(c).then(n,t=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=t),d(t))),f=Object.assign(u,{__abortController:o,__staleWhileFetching:h,__returned:void 0});return void 0===e?(this.set(t,f,{...l.options,status:void 0}),e=this.#c.get(t)):this.#f[e]=f,f}#b(t){return!!this.#k&&!!t&&t instanceof Promise&&t.hasOwnProperty("__staleWhileFetching")&&t.__abortController instanceof r}async fetch(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:o=this.noDisposeOnSet,size:a=0,sizeCalculation:l=this.sizeCalculation,noUpdateTTL:n=this.noUpdateTTL,noDeleteOnFetchRejection:d=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:c=this.allowStaleOnFetchRejection,ignoreFetchAbort:u=this.ignoreFetchAbort,allowStaleOnFetchAbort:f=this.allowStaleOnFetchAbort,context:p,forceRefresh:g=!1,status:v,signal:m}=e;if(!this.#k)return v&&(v.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:h,status:v});let y={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:h,ttl:r,noDisposeOnSet:o,size:a,sizeCalculation:l,noUpdateTTL:n,noDeleteOnFetchRejection:d,allowStaleOnFetchRejection:c,allowStaleOnFetchAbort:f,ignoreFetchAbort:u,status:v,signal:m},S=this.#c.get(t);if(void 0===S){v&&(v.fetch="miss");let e=this.#w(t,S,y,p);return e.__returned=e}{let e=this.#f[S];if(this.#b(e)){let t=i&&void 0!==e.__staleWhileFetching;return v&&(v.fetch="inflight",t&&(v.returnedStale=!0)),t?e.__staleWhileFetching:e.__returned=e}let h=this.#D(S);if(!g&&!h)return v&&(v.fetch="hit"),this.#E(S),s&&this.#B(S),v&&this.#U(v,S),e;let r=this.#w(t,S,y,p),o=void 0!==r.__staleWhileFetching&&i;return v&&(v.fetch=h?"stale":"refresh",o&&h&&(v.returnedStale=!0)),o?r.__staleWhileFetching:r.__returned=r}}async forceFetch(t,e={}){let i=await this.fetch(t,e);if(void 0===i)throw Error("fetch() returned undefined");return i}memo(t,e={}){let i=this.#a;if(!i)throw Error("no memoMethod provided to constructor");let{context:s,forceRefresh:h,...r}=e,o=this.get(t,r);if(!h&&void 0!==o)return o;let a=i(t,o,{options:r,context:s});return this.set(t,a,r),a}get(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,status:r}=e,o=this.#c.get(t);if(void 0!==o){let e=this.#f[o],a=this.#b(e);return(r&&this.#U(r,o),this.#D(o))?(r&&(r.get="stale"),a)?(r&&i&&void 0!==e.__staleWhileFetching&&(r.returnedStale=!0),i?e.__staleWhileFetching:void 0):(h||this.#R(t,"expire"),r&&i&&(r.returnedStale=!0),i?e:void 0):(r&&(r.get="hit"),a)?e.__staleWhileFetching:(this.#E(o),s&&this.#B(o),e)}r&&(r.get="miss")}#q(t,e){this.#g[e]=t,this.#p[t]=e}#E(t){t!==this.#m&&(t===this.#v?this.#v=this.#p[t]:this.#q(this.#g[t],this.#p[t]),this.#q(this.#m,t),this.#m=t)}delete(t){return this.#R(t,"delete")}#R(t,e){let i=!1;if(0!==this.#n){let s=this.#c.get(t);if(void 0!==s)if(this.#_?.[s]&&(clearTimeout(this.#_?.[s]),this.#_[s]=void 0),i=!0,1===this.#n)this.#V(e);else{this.#G(s);let i=this.#f[s];if(this.#b(i)?i.__abortController.abort(Error("deleted")):(this.#x||this.#F)&&(this.#x&&this.#s?.(i,t,e),this.#F&&this.#S?.push([i,t,e])),this.#c.delete(t),this.#u[s]=void 0,this.#f[s]=void 0,s===this.#m)this.#m=this.#g[s];else if(s===this.#v)this.#v=this.#p[s];else{let t=this.#g[s];this.#p[t]=this.#p[s];let e=this.#p[s];this.#g[e]=this.#g[s]}this.#n--,this.#y.push(s)}}if(this.#F&&this.#S?.length){let t,e=this.#S;for(;t=e?.shift();)this.#r?.(...t)}return i}clear(){return this.#V("delete")}#V(t){for(let e of this.#M({allowStale:!0})){let i=this.#f[e];if(this.#b(i))i.__abortController.abort(Error("deleted"));else{let s=this.#u[e];this.#x&&this.#s?.(i,s,t),this.#F&&this.#S?.push([i,s,t])}}if(this.#c.clear(),this.#f.fill(void 0),this.#u.fill(void 0),this.#T&&this.#L){for(let t of(this.#T.fill(0),this.#L.fill(0),this.#_??[]))void 0!==t&&clearTimeout(t);this.#_?.fill(void 0)}if(this.#z&&this.#z.fill(0),this.#v=0,this.#m=0,this.#y.length=0,this.#d=0,this.#n=0,this.#F&&this.#S){let t,e=this.#S;for(;t=e?.shift();)this.#r?.(...t)}}}t.s(["LRUCache",()=>c])}];

//# sourceMappingURL=87f17_lru-cache_dist_esm_index_d904ebb8.js.map